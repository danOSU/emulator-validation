#!/usr/bin/env python3
"""
Generates plots / figures when run as a script.
Plot files are placed in the :file:`plots` directory.

By default, simply running ``python -m src.plots`` generates **ALL** plots,
which may not be desired.  Instead, one can pass a list of plots to generate:
``python -m src.plots plot1 plot2 ...``.  The full list of plots is shown in
the usage information ``python -m src.plots --help``.

Typing can be reduced by using shell brace expansion, e.g. ``python -m
src.plots observables_{design,posterior}`` for both ``observables_design`` and
``observables_posterior``.  In addition, plots may be given as paths to plot
filenames, which enables shell globbing, e.g. ``python -m src.plots
plots/observables_*``.

In the code, each plot is generated by a function tagged with the ``@plot``
decorator.
"""

from collections import OrderedDict
import itertools
import logging
from pathlib import Path
import subprocess
import tempfile
import warnings

import h5py
import hsluv
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import lines
from matplotlib import patches
from matplotlib import ticker
from scipy import special
from scipy.interpolate import PchipInterpolator
import pandas as pd
from textwrap import fill
import dill

from bayes_mcmc import Chain, credible_interval
from configurations import *
from emulator import Trained_Emulators, _Covariance
from calculations_load import trimmed_model_data, MAP_data
from bayes_exp import Y_exp_data
from design import Design

fontsize = dict(
    large=11,
    normal=10,
    small=9,
    tiny=8,
)

qm_font_large = 11
qm_font_small = 9

cb,co,cg,cr = plt.cm.Blues(.6), \
    plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'

# new tableau colors
# https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
colors = OrderedDict([
    ('blue', '#4e79a7'),
    ('orange', '#f28e2b'),
    ('green', '#59a14f'),
    ('red', '#e15759'),
    ('cyan', '#76b7b2'),
    ('purple', '#b07aa1'),
    ('brown', '#9c755f'),
    ('yellow', '#edc948'),
    ('pink', '#ff9da7'),
    ('gray', '#bab0ac')
])

offblack = '.15'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic:medium',
    'mathtext.cal': 'sans',
    'font.size': fontsize['normal'],
    'legend.fontsize': fontsize['normal'],
    'axes.labelsize': fontsize['normal'],
    'axes.titlesize': fontsize['large'],
    'xtick.labelsize': fontsize['small'],
    'ytick.labelsize': fontsize['small'],
    #'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'axes.prop_cycle': plt.cycler('color', list(colors.values())),
    'lines.linewidth': .8,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .8,
    'axes.linewidth': .6,
    'xtick.major.width': .6,
    'ytick.major.width': .6,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 3.,
    'ytick.major.size': 3.,
    'xtick.minor.size': 2.,
    'ytick.minor.size': 2.,
    'xtick.major.pad': 3.5,
    'ytick.major.pad': 3.5,
    'axes.labelpad': 4.,
    'axes.formatter.limits': (-5, 5),
    'axes.spines.top': False,
    'axes.spines.right': False,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.frameon': False,
    'image.cmap': 'Blues',
    'image.interpolation': 'none',
})




plotdir = workdir / 'plots'
plotdir.mkdir(exist_ok=True)
plot_functions = {}

def plot(f):
    """
    Plot function decorator.  Calls the function, does several generic tasks,
    and saves the figure as the function name.

    """
    def wrapper(*args, **kwargs):
        logging.info('generating plot: %s', f.__name__)
        f(*args, **kwargs)

        fig = plt.gcf()

        """
        if not fig.get_tight_layout():
            set_tight(fig)
        """

        plotfile = plotdir / '{}.png'.format(f.__name__)
        fig.savefig(str(plotfile), dpi=300)
        logging.info('wrote %s', plotfile)
        plt.close(fig)

    plot_functions[f.__name__] = wrapper

    return wrapper


def figsize(relwidth=1, aspect=.618, refwidth=6):
    """
    Return figure dimensions from a relative width (to a reference width) and
    aspect ratio (default: 1/golden ratio).

    """
    width = relwidth * refwidth
    return width, width*aspect


def set_tight(fig=None, **kwargs):
    """
    Set tight_layout with a better default pad.

    """
    if fig is None:
        fig = plt.gcf()

    kwargs.setdefault('pad', .1)
    fig.set_tight_layout(kwargs)


def auto_ticks(ax, axis='both', minor=False, **kwargs):
    """
    Convenient interface to matplotlib.ticker locators.

    """
    axis_list = []

    if axis in {'x', 'both'}:
        axis_list.append(ax.xaxis)
    if axis in {'y', 'both'}:
        axis_list.append(ax.yaxis)

    for axis in axis_list:
        axis.get_major_locator().set_params(**kwargs)
        if minor:
            axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def format_system(system):
    """
    Format a system string into a display name, e.g.:

    >>> format_system('PbPb2760')
    'Pb-Pb 2.76 TeV'

    >>> format_system('AuAu200')
    'Au-Au 200 GeV'

    """
    proj, energy = parse_system(system)

    if energy > 1000:
        energy /= 1000
        prefix = 'T'
    else:
        prefix = 'G'

    return '{} {} {}eV'.format('-'.join(proj), energy, prefix)


def darken(rgb, amount=.5):
    """
    Darken a color by the given amount in HSLuv space.

    """
    H, S, L = hsluv.rgb_to_hsluv(rgb)
    return hsluv.hsluv_to_rgb((H, S, (1 - amount)*L))


def obs_color_hsluv(obs, subobs):
    """
    Return a nice color for the given observable in HSLuv space.
    Use obs_color() to obtain an RGB color.

    """
    if obs in {'dNch_deta', 'pT_fluct'}:
        return 250, 90, 55

    if obs == 'dET_deta':
        return 10, 65, 55

    if obs in {'dN_dy', 'mean_pT'}:
        return dict(
            pion=(210, 85, 70),
            kaon=(130, 88, 68),
            proton=(30, 90, 62),
        )[subobs]

    if obs == 'vnk':
        return {
            (2, 2): (230, 90, 65),
            (2, 4): (262, 80, 63),
            (3, 2): (150, 90, 67),
            (4, 2): (310, 70, 50),
        }[subobs]

    raise ValueError('unknown observable: {} {}'.format(obs, subobs))


def obs_color(obs, subobs):
    """
    Return a nice color for the given observable.

    """
    return hsluv.hsluv_to_rgb(obs_color_hsluv(obs, subobs))


def obs_label(obs, subobs, differentials=False, full_cumulants=False):
    """
    Return a formatted label for the given observable.

    """
    if obs.startswith('d') and obs.endswith('_deta'):
        return (r'$d{}/d\eta$' if differentials else '${}$').format(
            {'Nch': r'N_\mathrm{ch}', 'ET': r'E_T'}[obs[1:-5]])

    id_parts_labels = {
        'dN_dy': '$dN_{}/dy$' if differentials else '$N_{}$',
        'mean_pT': r'$\langle p_T^{} \rangle$'
    }
    if obs in id_parts_labels:
        return id_parts_labels[obs].format(
            {'pion': '\pi', 'kaon': 'K', 'proton': 'p'}[subobs]
        )

    if obs == 'pT_fluct':
        return r'$\delta p_T/\langle p_T \rangle$'

    if obs == 'vnk':
        n, k = subobs
        return '$v_{}{}$'.format(
            n,
            (r'\{' + str(k) + r'\}') if full_cumulants else ''
        )
obs_tex_labels = {
                    'dNch_deta' : r'$dN_{ch}/d\eta$',
                    'dN_dy_pion' : r'$dN_{\pi}/dy$',
                    'dN_dy_kaon' : r'$dN_{k}/dy$',
                    'dN_dy_proton' : r'$dN_{p}/dy$',
                    'dN_dy_Lambda' : r'$dN_{\Lambda}/dy$',
                    'dN_dy_Omega' : r'$dN_{\Omega}/dy$',
                    'dN_dy_Xi' : r'$dN_{\Xi}/dy$',
                    'dN_dy_d' : r'$dN_{d}/dy$',
                    'dET_deta' : r'$dE_{T}/d\eta$',
                    'mean_pT_pion' : r'$\pi$',
                    'mean_pT_kaon' : r'$k$',
                    'mean_pT_proton' : r'$p$',
                    'mean_pT_d' : r'$d$',
                    'pT_fluct' : None,
                    'v22' : r'$v_2\{2\}$',
                    'v32' : r'$v_3\{2\}$',
                    'v42' : r'$v_4\{2\}$',
                    'v22_d' : r'$v_2\{2\}_{d}$',
}

obs_tex_labels_2 = {
                    'dNch_deta' : r'$dN_{ch}/d\eta$',
                    'dN_dy_pion' : r'$dN_{\pi}/dy$',
                    'dN_dy_kaon' : r'$dN_{k}/dy$',
                    'dN_dy_proton' : r'$dN_{p}/dy$',
                    'dN_dy_Lambda' : r'$dN_{\Lambda}/dy$',
                    'dN_dy_Omega' : r'$dN_{\Omega}/dy$',
                    'dN_dy_Xi' : r'$dN_{\Xi}/dy$',
                    'dET_deta' : r'$dE_{T}/d\eta$',
                    'mean_pT_pion' : r'$\langle p_T \rangle _{\pi}$',
                    'mean_pT_kaon' : r'$\langle p_T \rangle _{k}$',
                    'mean_pT_proton' : r'$\langle p_T \rangle _{p}$',
                    'pT_fluct' : r'$\delta p_T / \langle p_T \rangle$',
                    'v22' : r'$v_2\{2\}$',
                    'v32' : r'$v_3\{2\}$',
                    'v42' : r'$v_4\{2\}$',
}

def _observables(posterior=False, ratio=False):
    """
    Model observables at all design points or drawn from the posterior with
    experimental data points.

    """
    if posterior:
        print("Plotting observables drawn from posterior")
        #print("Chain.shape = " + str(Chain.shape))
        Ymodel = Chain().samples(100)
    else:
        Ymodel = trimmed_model_data

    if validation:
        #get VALIDATION points
        design_file = design_dir + '/design_points_validation_{:s}{:s}-{:d}.dat'.format(*systems[0])
        logging.info("Loading design points from " + design_file)
        design = pd.read_csv(design_file)
        design = design.drop("idx", axis=1)
        truth = design.values[validation_pt]
        #Yexp = Y_exp_data[validation_pt]
        Yexp = Y_exp_data[0]

    else:
        Yexp = Y_exp_data

    highlight_sets =  []

    num_of_obs = np.sum([len(active_obs_list[s]) for s in system_strs])
    print("active_obs_list = " + str(active_obs_list))
    fig, axes = plt.subplots(nrows=4, ncols=5, figsize=(10,7), sharex=True)
    na_start = 0
    na_stop = 0
    for system in system_strs:
        na_stop += len(active_obs_list[system])
        subaxes = axes.flatten()[na_start:na_stop]
        na_start = na_stop
        for obs, ax in zip(active_obs_list[system], subaxes):
            # sys labels
            ax.annotate(system, xy=(.4, .9), xycoords="axes fraction")

            # Centrality bins
            xbins = np.array(obs_cent_list[system][obs])
            x = (xbins[:,0]+xbins[:,1])/2.

            # plot exp
            try:
                exp_mean = Yexp[system][obs]['mean'][idf]
                exp_err = Yexp[system][obs]['err'][idf]
            except KeyError:
                continue
            ax.errorbar(x, np.ones_like(x) if ratio else exp_mean,
                        yerr=exp_err/exp_mean if ratio else exp_err,
                        fmt='ko')

            # plot calc
            if posterior:
                Y = Ymodel[system][obs]
            else:
                Y = Ymodel[system][obs]['mean'][idf]

            alpha = 0.4
            lw = 0.15
            colour = cr
            if posterior:
                if ratio:
                    y = Y/exp_mean
                    ax.fill_between(x,
                            np.percentile(y, 5, axis=0),
                            np.percentile(y, 95, axis=0),
                            color=colour, alpha=alpha
                    )
                    ax.fill_between(x,
                            np.percentile(y, 20, axis=0),
                            np.percentile(y, 80, axis=0),
                            color=colour, alpha=alpha
                    )
                else:
                    ax.plot(x, Y.T, color=colour, alpha=alpha, lw=lw)
            else:
                ax.plot(x, (Y/exp_mean).T if ratio else Y.T,
                        color=colour, alpha=alpha, lw=lw)
            # axis and limits
            ax.set_xlim(0, 70)
            if ratio:
                ax.set_ylim(0.5, 1.5)
                ax.plot([0,70],[1,1],'k--', alpha=0.6)
                ax.fill_between([0,70],[.9,.9], [1.1,1.1],color='k', alpha=0.2)
            else:
                ax.set_ylim(*obs_range_list[system][obs])
            auto_ticks(ax, 'x', nbins=5, minor=2)

            if ax.is_last_row():
                ax.set_xlabel('Centrality %')

            ax.set_ylabel(obs)

    set_tight(fig, rect=[0, 0, .97, 1])

@plot
def observables_fit():
    """
    Model observables at all design points or drawn from the posterior with
    experimental data points.

    """
    print("Plotting observables drawn from posterior")

    obs_groups = {
                'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dN_dy_Lambda', 'dN_dy_Omega', 'dN_dy_Xi', 'dNch_deta', 'dET_deta'],
                'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton'],
                'flows' : ['v22', 'v32', 'v42'],
                'fluct' : ['pT_fluct']
                }
    obs_group_labels = {
                'yields' : r'$dN_{ch}/d\eta$ , $dN/dy$, $dE_T/d\eta$ [GeV]',
                'mean_pT' : r'$ \langle p_T \rangle$',
                'fluct' : r'$\delta p_T / \langle p_T \rangle$',
                'flows' : r'$v_n \{ 2 \} $'
                }

    colors = ['b', 'g', 'r', 'c', 'm', 'tan', 'orange', 'gray']
    Ymodel = Chain().samples(100)
    Yexp = Y_exp_data
    n_systems = len(system_strs)
    nrows = 4
    height_ratios = [1.8, 1.2, 1.5, 1.]
    if system_strs == ['Au-Au-200']:
        nrows = 3
        height_ratios = [1.8, 1.2, 1.5]
        del obs_groups['fluct']

    fig, axes = plt.subplots(nrows=nrows, ncols=n_systems, figsize=(2.5*n_systems,9), squeeze=False, gridspec_kw={'height_ratios': height_ratios})
    #fig.suptitle("Observables Posterior : " + idf_label[idf] + " \n Visc. Correction ")
    for row, obs_group in enumerate( obs_groups.keys() ):
        for obs, color in zip(obs_groups[obs_group], colors):
            for col, system in enumerate(system_strs):
                if system == 'Pb-Pb-2760' or system == 'Xe-Xe-5440':
                    expt_label='ALICE'
                    expt_marker='v'
                if system == 'Au-Au-200':
                    expt_label='STAR'
                    expt_marker='.'

                axes[row][col].tick_params(labelsize=11)

                if obs in active_obs_list[system]:
                    if obs_group == 'yields':
                        axes[row][col].set_yscale('log')
                    scale = 1.0
                    if obs == 'dET_deta':
                        scale = 5.
                    if obs == 'dNch_deta':
                        scale = 2.
                    try :
                        axes[row][col].set_ylabel(obs_group_labels[obs_group], fontsize=qm_font_large)
                        xbins = np.array(obs_cent_list[system][obs])
                        x = (xbins[:,0]+xbins[:,1])/2.
                        Y = Ymodel[system][obs]
                        for iy, y in enumerate(Y):
                            is_mult = ('dN' in obs) or ('dET' in obs)
                            if is_mult and transform_multiplicities:
                                y = np.exp(y) - 1.0
                            label = None
                            if iy == 0:
                                if scale == 1.0 :
                                    label=obs_tex_labels[obs]
                                else :
                                    label=obs_tex_labels[obs] + 'x' + str(scale)
                            axes[row][col].plot(x, y*scale, alpha=0.3, lw=0.3, color=color, label=label)
                        try:
                            #exp_mean = Yexp[system][obs]['mean'][:, 0][0]
                            #exp_err = Yexp[system][obs]['err'][:, 0][0]
                            exp_mean = Yexp[system][obs]['mean'][idf]
                            exp_err = Yexp[system][obs]['err'][idf]
                        except KeyError:
                            continue

                        if system=='Pb-Pb-2760':
                            l1 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)
                        elif system=='Au-Au-200':
                            l2 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)

                    except KeyError :
                        continue

                    leg = axes[row][col].legend(fontsize=qm_font_small, borderpad=0, labelspacing=0, handlelength=1, handletextpad=0.2)
                    for legobj in leg.legendHandles:
                        legobj.set_linewidth(2.0)
                        legobj.set_alpha(1.0)

                    if system == 'Au-Au-200':
                        axes[row][col].set_xlim(0, 50)
                    else :
                        axes[row][col].set_xlim(0, 70)

                    if obs_group == 'yields':
                        axes[row][col].set_ylim(1e-1, 1e5)
                    if obs_group == 'mean_pT':
                        axes[row][col].set_ylim(0., 1.5)
                    if obs_group == 'fluct':
                        axes[row][col].set_ylim(0.0, 0.04)
                    if obs_group == 'flows':
                        axes[row][col].set_ylim(0.0, 0.12)
                    if axes[row][col].is_last_row():
                        axes[row][col].set_xlabel('Centrality %', fontsize=qm_font_large)
                else :
                    continue

    if num_systems == 2:
        fig.delaxes(axes[3][1])
    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .93])
    fig.suptitle("Observables Posterior : " + idf_label[idf], wrap=True)

@plot
def observables_fit_MAP():
    """
    Model observables calculated at MAP parameters with hybrid model, with
    experimental data points.

    """
    print("Plotting observables calculated at MAP params by hybrid model")

    plot_exp = True # if True, plot experimental data. if False, plot emu mean prediction

    obs_groups = {
                #'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dNch_deta', 'dET_deta'],
                'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dN_dy_d'],
                #'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton'],
                'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton', 'mean_pT_d'],
                'flows' : ['v22', 'v32', 'v42'],
                'fluct' : ['pT_fluct']
                }
    obs_group_labels = {
                'yields' : r'$dN_{ch}/d\eta$ , $dN/dy$, $dE_T/d\eta$ [GeV]',
                'mean_pT' : r'$ \langle p_T \rangle$',
                'fluct' : r'$\delta p_T / \langle p_T \rangle$',
                'flows' : r'$v_n \{ 2 \} $'
                }

    colors = ['b', 'g', 'r', 'c', 'm', 'tan', 'gray']
    Ymodel = MAP_data
    Yexp = Y_exp_data
    n_systems = len(system_strs)
    nrows = 4
    #height_ratios = [1.8, 1.2, 1.5]
    height_ratios = [1.8, 1.2, 1.5, 1.]
    if system_strs == ['Au-Au-200']:
        nrows = 3
        height_ratios = [1.8, 1.2, 1.5]
        del obs_groups['fluct']

    fig, axes = plt.subplots(nrows=nrows, ncols=n_systems, figsize=(2.5*n_systems,9), squeeze=False, gridspec_kw={'height_ratios': height_ratios})
    for row, obs_group in enumerate( obs_groups.keys() ):
        for obs, color in zip(obs_groups[obs_group], colors):

            for col, system in enumerate(system_strs):
                if system == 'Pb-Pb-2760' or system == 'Xe-Xe-5440':
                    expt_label='ALICE'
                    expt_marker='v'
                if system == 'Au-Au-200':
                    expt_label='STAR'
                    expt_marker='.'
                emu = dill.load(open('emulator/emulator-' + system + '-idf-' + str(idf) + '.dill', "rb"))

                #the MAP parameters for Grad
                MAP_params = {
                            'Pb-Pb-2760': [14.128, 0.089, 1.054, 1.064, 4.227, 1.507, 0.113, 0.223, -1.585, 0.32, 0.056, 0.11, 0.16, 0.093, -0.084, 4.666, 0.136],
                            'Au-Au-200' : [5.821, 0.089, 1.054, 1.064, 4.227, 1.507, 0.113, 0.223, -1.585, 0.32, 0.056, 0.11, 0.16, 0.093, -0.084, 4.666, 0.136]
                }

                axes[row][col].tick_params(labelsize=11)

                if obs in active_obs_list[system]:

                    #Yemu_mean = emu.predict( np.array( [MAP_params[system]] ) )
                    #y_emu = Yemu_mean[obs][0]

                    if obs_group == 'yields':
                        axes[row][col].set_yscale('log')
                    scale = 1.0
                    if obs == 'dET_deta':
                        scale = 5.
                    if obs == 'dNch_deta':
                        scale = 2.
                    if obs == 'dN_dy_d':
                        scale = 200.
                    try :
                        axes[row][col].set_ylabel(obs_group_labels[obs_group], fontsize=qm_font_large)
                        xbins = np.array(obs_cent_list[system][obs])
                        x = (xbins[:,0]+xbins[:,1])/2.
                        Y = Ymodel[system][obs]['mean'][idf][0]
                        Yerr = Ymodel[system][obs]['err'][idf][0]
                        is_mult = ('dN' in obs) or ('dET' in obs)
                        if is_mult and transform_multiplicities:
                            Y = np.exp(Y) - 1.0
                        if scale == 1.0 :
                            label=obs_tex_labels[obs]
                        else :
                            label=obs_tex_labels[obs] + 'x' + str(scale)
                        axes[row][col].plot(x, Y*scale, color=color, label=label, lw=2.0)
                        if not plot_exp:
                            axes[row][col].scatter(x, y_emu*scale, color=color, marker='o', lw=2.0)
                        axes[row][col].fill_between(x, (Y-Yerr)*scale, (Y+Yerr)*scale, color=color, alpha=0.3)
                        try:
                            exp_mean = Yexp[system][obs]['mean'][idf]
                            exp_err = Yexp[system][obs]['err'][idf]
                        except KeyError:
                            pass

                        if plot_exp:
                            if system=='Pb-Pb-2760':
                                l1 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)
                            elif system=='Au-Au-200':
                                l2 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)

                    except KeyError :
                        pass

                    leg = axes[row][col].legend(fontsize=qm_font_small, borderpad=0, labelspacing=0, handlelength=1, handletextpad=0.2)
                    for legobj in leg.legendHandles:
                        legobj.set_linewidth(2.0)
                        legobj.set_alpha(1.0)

                    if system == 'Au-Au-200':
                        axes[row][col].set_xlim(0, 50)
                    else :
                        axes[row][col].set_xlim(0, 70)

                    if obs_group == 'yields':
                        axes[row][col].set_ylim(1, 1e4)
                    if obs_group == 'mean_pT':
                        axes[row][col].set_ylim(0., 2.5)
                    if obs_group == 'fluct':
                        axes[row][col].set_ylim(0.0, 0.04)
                    if obs_group == 'flows':
                        axes[row][col].set_ylim(0.0, 0.12)
                    if axes[row][col].is_last_row():
                        axes[row][col].set_xlabel('Centrality %', fontsize=qm_font_large)
                else :
                    pass

    if num_systems == 2:
        fig.delaxes(axes[3][1])
    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .93])
    fig.suptitle("Observables at MAP : " + idf_label[idf], wrap=True)

@plot
def observables_fit_deuteron():
    """
    Model observables calculated at MAP parameters with hybrid model, with
    experimental data points.

    """
    print("Plotting observables calculated at MAP params by hybrid model")

    obs_groups = {
                'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dN_dy_d'],
                'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton', 'mean_pT_d'],
                'flows' : ['v22', 'v32', 'v42', 'v22_d'],
                }
    obs_group_labels = {
                'yields' : r'$dN_{ch}/d\eta$ , $dN/dy$, $dE_T/d\eta$ [GeV]',
                'mean_pT' : r'$ \langle p_T \rangle$',
                'fluct' : r'$\delta p_T / \langle p_T \rangle$',
                'flows' : r'$v_n \{ 2 \} $'
                }

    colors = ['b', 'g', 'r', 'c', 'm', 'tan', 'gray']
    Ymodel = MAP_data
    Yexp = Y_exp_data
    n_systems = len(system_strs)
    nrows = 3
    height_ratios = [1.8, 1.2, 1.5]
    if system_strs == ['Au-Au-200']:
        nrows = 3
        height_ratios = [1.8, 1.2, 1.5]
        del obs_groups['fluct']

    fig, axes = plt.subplots(nrows=nrows, ncols=n_systems, figsize=(2.5*n_systems,9), squeeze=False, gridspec_kw={'height_ratios': height_ratios})
    for row, obs_group in enumerate( obs_groups.keys() ):
        for obs, color in zip(obs_groups[obs_group], colors):

            for col, system in enumerate(system_strs):
                if system == 'Pb-Pb-2760' or system == 'Xe-Xe-5440':
                    expt_label='ALICE'
                    expt_marker='v'
                if system == 'Au-Au-200':
                    expt_label='STAR'
                    expt_marker='.'

                axes[row][col].tick_params(labelsize=11)

                if obs in active_obs_list[system]:

                    if obs_group == 'yields':
                        axes[row][col].set_yscale('log')
                    scale = 1.0
                    if obs == 'dET_deta':
                        scale = 5.
                    if obs == 'dNch_deta':
                        scale = 2.
                    if obs == 'dN_dy_d':
                        scale = 200.
                    try :
                        axes[row][col].set_ylabel(obs_group_labels[obs_group], fontsize=qm_font_large)
                        xbins = np.array(obs_cent_list[system][obs])
                        x = (xbins[:,0]+xbins[:,1])/2.
                        Y = Ymodel[system][obs]['mean'][idf][0]
                        Yerr = Ymodel[system][obs]['err'][idf][0]
                        is_mult = ('dN' in obs) or ('dET' in obs)
                        if is_mult and transform_multiplicities:
                            Y = np.exp(Y) - 1.0
                        if scale == 1.0 :
                            label=obs_tex_labels[obs]
                        else :
                            label=obs_tex_labels[obs] + 'x' + str(scale)
                        axes[row][col].plot(x, Y*scale, color=color, label=label, lw=2.0)
                        axes[row][col].fill_between(x, (Y-Yerr)*scale, (Y+Yerr)*scale, color=color, alpha=0.3)
                        try:
                            exp_mean = Yexp[system][obs]['mean'][idf]
                            exp_err = Yexp[system][obs]['err'][idf]
                        except KeyError:
                            pass

                        if system=='Pb-Pb-2760':
                            l1 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)
                        elif system=='Au-Au-200':
                            l2 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)

                    except KeyError :
                        pass

                    leg = axes[row][col].legend(fontsize=qm_font_small, borderpad=0, labelspacing=0, handlelength=1, handletextpad=0.2)
                    for legobj in leg.legendHandles:
                        legobj.set_linewidth(2.0)
                        legobj.set_alpha(1.0)

                    if system == 'Au-Au-200':
                        axes[row][col].set_xlim(0, 50)
                    else :
                        axes[row][col].set_xlim(0, 70)

                    if obs_group == 'yields':
                        axes[row][col].set_ylim(1, 1e4)
                    if obs_group == 'mean_pT':
                        axes[row][col].set_ylim(0., 2.5)
                    if obs_group == 'fluct':
                        axes[row][col].set_ylim(0.0, 0.04)
                    if obs_group == 'flows':
                        axes[row][col].set_ylim(0.0, 0.12)
                    if axes[row][col].is_last_row():
                        axes[row][col].set_xlabel('Centrality %', fontsize=qm_font_large)
                else :
                    pass

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .93])
    fig.suptitle("Observables at MAP : " + idf_label[idf], wrap=True)

@plot
def observables_fit_model_calc_compare():
    """
    Compare Model observables calculated at 2 parameter sets with hybrid model, with
    experimental data points.

    """

    #from compare_events import *

    print("Plotting observables calculated at 2 param sets by hybrid model")

    obs_groups = {
                'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dNch_deta', 'dET_deta'],
                #'yields' : ['dN_dy_pion', 'dN_dy_kaon', 'dN_dy_proton', 'dN_dy_d'],
                'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton'],
                #'mean_pT' : ['mean_pT_pion', 'mean_pT_kaon', 'mean_pT_proton', 'mean_pT_d'],
                'flows' : ['v22', 'v32', 'v42'],
                'fluct' : ['pT_fluct']
                }
    obs_group_labels = {
                'yields' : r'$dN_{ch}/d\eta$ , $dN/dy$, $dE_T/d\eta$ [GeV]',
                'mean_pT' : r'$ \langle p_T \rangle$',
                'fluct' : r'$\delta p_T / \langle p_T \rangle$',
                'flows' : r'$v_n \{ 2 \} $'
                }

    colors = ['b', 'g', 'r', 'c', 'm', 'tan', 'gray']
    Ymodel1 = model_data_1
    Ymodel2 = model_data_2
    Yexp = Y_exp_data
    n_systems = len(system_strs)
    nrows = 4
    #height_ratios = [1.8, 1.2, 1.5]
    height_ratios = [1.8, 1.2, 1.5, 1.]
    if system_strs == ['Au-Au-200']:
        nrows = 3
        height_ratios = [1.8, 1.2, 1.5]
        del obs_groups['fluct']

    fig, axes = plt.subplots(nrows=nrows, ncols=n_systems, figsize=(2.5*n_systems,9), squeeze=False, gridspec_kw={'height_ratios': height_ratios})
    for row, obs_group in enumerate( obs_groups.keys() ):
        for obs, color in zip(obs_groups[obs_group], colors):

            for col, system in enumerate(system_strs):
                if system == 'Pb-Pb-2760' or system == 'Xe-Xe-5440':
                    expt_label='ALICE'
                    expt_marker='v'
                if system == 'Au-Au-200':
                    expt_label='STAR'
                    expt_marker='.'
                emu = dill.load(open('emulator/emulator-' + system + '-idf-' + str(idf) + '.dill', "rb"))

                axes[row][col].tick_params(labelsize=11)

                if obs in active_obs_list[system]:

                    if obs_group == 'yields':
                        axes[row][col].set_yscale('log')
                    scale = 1.0
                    if obs == 'dET_deta':
                        scale = 5.
                    if obs == 'dNch_deta':
                        scale = 2.
                    if obs == 'dN_dy_d':
                        scale = 200.
                    try :
                        axes[row][col].set_ylabel(obs_group_labels[obs_group], fontsize=qm_font_large)
                        xbins = np.array(obs_cent_list[system][obs])
                        x = (xbins[:,0]+xbins[:,1])/2.
                        Y1 = Ymodel1[system][obs]['mean'][idf][0]
                        Y2 = Ymodel2[system][obs]['mean'][idf][0]
                        Y1err = Ymodel1[system][obs]['err'][idf][0]
                        Y2err = Ymodel2[system][obs]['err'][idf][0]
                        if scale == 1.0 :
                            label=obs_tex_labels[obs]
                        else :
                            label=obs_tex_labels[obs] + 'x' + str(scale)
                        #axes[row][col].plot(x, Y1*scale, color=color, label=label, lw=2.0)
                        #axes[row][col].plot(x, Y2*scale, 'o', color=color, label=None)
                        axes[row][col].errorbar(x, Y1*scale, Y1err*scale, color=color, label=label, lw=2.0)
                        axes[row][col].errorbar(x, Y2*scale, Y2err*scale, color=color, marker='o', label=None, ls='none', markersize=4)
                        try:
                            exp_mean = Yexp[system][obs]['mean'][idf]
                            exp_err = Yexp[system][obs]['err'][idf]
                        except KeyError:
                            pass

                        #if system=='Pb-Pb-2760':
                        #    l1 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)
                        #elif system=='Au-Au-200':
                        #    l2 = axes[row][col].errorbar( x, exp_mean*scale, exp_err, color='black', fmt=expt_marker, markersize='4', elinewidth=1)

                    except KeyError :
                        pass

                    leg = axes[row][col].legend(fontsize=qm_font_small, borderpad=0, labelspacing=0, handlelength=1, handletextpad=0.2)
                    for legobj in leg.legendHandles:
                        legobj.set_linewidth(2.0)
                        legobj.set_alpha(1.0)

                    if system == 'Au-Au-200':
                        axes[row][col].set_xlim(0, 50)
                    else :
                        axes[row][col].set_xlim(0, 70)

                    if obs_group == 'yields':
                        axes[row][col].set_ylim(1, 1e4)
                    if obs_group == 'mean_pT':
                        axes[row][col].set_ylim(0., 2.5)
                    if obs_group == 'fluct':
                        axes[row][col].set_ylim(0.0, 0.04)
                    if obs_group == 'flows':
                        axes[row][col].set_ylim(0.0, 0.12)
                    if axes[row][col].is_last_row():
                        axes[row][col].set_xlabel('Centrality %', fontsize=qm_font_large)
                else :
                    pass

    if num_systems == 2:
        fig.delaxes(axes[3][1])
    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .93])
    fig.suptitle("Varying Bulk Relaxation Time", wrap=True)


@plot
def obs_validation():
    _observables(posterior=True)

@plot
def obs_validation_ratio():
    _observables(posterior=True, ratio=True)

@plot
def obs_prior():
    _observables(posterior=False)


@plot
def observables_map():
    """
    Model observables and ratio to experiment at the maximum a posteriori
    (MAP) estimate.

    """
    plots = _observables_plots()

    ylim = {
        'Yields': (2, 1e5),
        'Flow cumulants': (0, .15),
        'Mean $p_T$': (0, 1.7),
        'Mean $p_T$ fluctuations': (0, .045),
    }

    for n, p in enumerate(plots):
        p['ylim'] = ylim[p['title']]
        if p['title'] == 'Flow cumulants':
            move_index = n
            p.update(
                ylabel=r'$v_n\{k\}$',
                subplots=[
                    ('vnk', nk, dict(label='$v_{}\{{{}\}}$'.format(*nk)))
                    for nk in [(2, 2), (2, 4), (3, 2), (4, 2)]
                ],
                legend=True
            )

    plots.insert(1, plots.pop(move_index))

    ncols = int(len(plots)/2)

    fig, axes = plt.subplots(
        nrows=4, ncols=ncols,
        figsize=figsize(1.1, aspect=2/ncols),
        gridspec_kw=dict(
            height_ratios=list(itertools.chain.from_iterable(
                (p.get('height_ratio', 1), .4) for p in plots[::ncols]
            ))
        )
    )

    labels = {}
    handles = dict(expt={}, model={})

    for plot, ax, ratio_ax in zip(plots, axes[::2].flat, axes[1::2].flat):
        for system, (obs, subobs, opts) in itertools.product(
                systems, plot['subplots']
        ):
            color = obs_color(obs, subobs)
            scale = opts.get('scale')

            linestyle, fill_markers = {
                'PbPb2760': ('solid', True),
                'PbPb5020': ('dashed', False),
            }[system]

            x = model.map_data[system][obs][subobs]['x']
            y = model.map_data[system][obs][subobs]['Y']

            if scale is not None:
                y = y*scale

            ax.plot(x, y, color=color, ls=linestyle)
            handles['model'][system] = \
                lines.Line2D([], [], color=offblack, ls=linestyle)

            if 'label' in opts and (obs, subobs) not in labels:
                labels[obs, subobs] = ax.text(
                    x[-1] + 3, y[-1],
                    opts['label'],
                    color=darken(color), ha='left', va='center'
                )

            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                continue

            x = dset['x']
            yexp = dset['y']
            yerr = dset['yerr']
            yerrstat = yerr.get('stat')
            yerrsys = yerr.get('sys', yerr.get('sum'))

            if scale is not None:
                yexp = yexp*scale
                if yerrstat is not None:
                    yerrstat = yerrstat*scale
                if yerrsys is not None:
                    yerrsys = yerrsys*scale

            c = '.25'
            handles['expt'][system] = ax.errorbar(
                x, yexp, yerr=yerrstat, fmt='o',
                capsize=0, color=c,
                mec=c, mfc=(c if fill_markers else '.9'),
                mew=((.2 if fill_markers else .5) *
                     plt.rcParams['lines.linewidth']),
                zorder=1000
            )

            ax.fill_between(
                x, yexp - yerrsys, yexp + yerrsys,
                facecolor='.9', zorder=-10,
            )

            ratio_ax.plot(x, y/yexp, color=color, ls=linestyle)

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        for a in [ax, ratio_ax]:
            a.set_xlim(0, 80)
            auto_ticks(a, 'x', nbins=5, minor=2)

        if ratio_ax.is_last_row():
            ratio_ax.set_xlabel('Centrality %')

        ax.set_ylim(plot['ylim'])
        ax.set_ylabel(plot['ylabel'])

        if plot.get('legend'):
            ax.legend(
                [handles[t][s] for t in ['model', 'expt'] for s in systems],
                [fmt.format(parse_system(s)[1]/1000)
                 for fmt in ['', '{} TeV'] for s in systems],
                ncol=2, loc='upper left', bbox_to_anchor=(0, .94),
                columnspacing=0, handletextpad=0
            )

        ax.text(
            .5, 1 if ax.is_first_row() else .97, plot['title'],
            transform=ax.transAxes, ha='center', va='top',
            size=plt.rcParams['axes.labelsize']
        )

        ratio_ax.axhline(
            1,
            linewidth=plt.rcParams['ytick.major.width'], color='0.5',
            zorder=-100
        )
        ratio_ax.axhspan(.9, 1.1, color='0.93', zorder=-200)
        ratio_ax.set_ylim(.85, 1.15)
        ratio_ax.set_ylabel('Ratio')
        ratio_ax.text(
            ratio_ax.get_xlim()[1], .9, '±10%',
            color='.5', zorder=-50,
            ha='right', va='bottom',
            size=plt.rcParams['xtick.labelsize']
        )

    set_tight(fig)


@plot
def observables_expt_only():
    """
    Observables plots of experimental data only.

    """
    plots = _observables_plots()

    ylim = {
        'Yields': (2, 1e5),
        'Flow cumulants': (0, .15),
        'Mean $p_T$': (0, 1.7),
        'Mean $p_T$ fluctuations': (0, .045),
    }

    for n, p in enumerate(plots):
        p['ylim'] = ylim[p['title']]
        if p['title'] == 'Flow cumulants':
            move_index = n
            p.update(legend=True)

    plots.insert(1, plots.pop(move_index))

    ncols = int(len(plots)/2)

    fig, axes = plt.subplots(
        nrows=2, ncols=ncols,
        figsize=figsize(1.1, aspect=1.5/ncols),
        gridspec_kw=dict(
            height_ratios=[p.get('height_ratio', 1) for p in plots[::ncols]]
        )
    )

    for plot, ax in zip(plots, axes.flat):
        labels = {}
        handles = {}

        for system, (obs, subobs, opts) in itertools.product(
                systems, plot['subplots']
        ):
            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                continue

            x = dset['x']
            yexp = dset['y']
            yerr = dset['yerr']
            yerrstat = yerr.get('stat')
            yerrsys = yerr.get('sys', yerr.get('sum'))

            scale = opts.get('scale')
            if scale is not None:
                yexp = yexp*scale
                if yerrstat is not None:
                    yerrstat = yerrstat*scale
                if yerrsys is not None:
                    yerrsys = yerrsys*scale

            color = obs_color(obs, subobs)
            fill_markers = {'PbPb2760': True, 'PbPb5020': False}[system]

            c = darken(color, .15)
            h = ax.errorbar(
                x, yexp, yerr=yerrstat, fmt='o',
                capsize=0, color=c,
                mec=c, mfc=(c if fill_markers else '.9'),
                mew=((.2 if fill_markers else .6) *
                     plt.rcParams['lines.linewidth']),
                zorder=1000
            )
            if system not in handles:
                handles[system] = h

            ax.fill_between(
                x, yexp - yerrsys, yexp + yerrsys,
                facecolor='.9', zorder=-10,
            )

            if 'label' in opts and (obs, subobs) not in labels:
                labels[obs, subobs] = ax.text(
                    x[-1] + 3, yexp[-1],
                    opts['label'],
                    color=darken(color), ha='left', va='center'
                )

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        ax.set_xlim(0, 80)
        auto_ticks(ax, 'x', nbins=5, minor=2)

        if ax.is_last_row():
            ax.set_xlabel('Centrality %')

        ax.set_ylim(plot['ylim'])
        ax.set_ylabel(plot['ylabel'])

        if plot.get('legend'):
            ax.legend(
                *zip(*[(handles[s], format_system(s)) for s in systems]),
                loc='upper left', bbox_to_anchor=(0, .94),
                handletextpad=0
            )

        ax.text(
            .5, 1 if ax.is_first_row() else .97, plot['title'],
            transform=ax.transAxes, ha='center', va='top',
            size=plt.rcParams['axes.labelsize']
        )

    set_tight(fig)



def corner(data, axes, ranges, labels, ptype='hist'):
    cmap = plt.get_cmap('Blues')
    cmap.set_bad('white')
    for i, row in enumerate(axes):
        for j, ax in enumerate(row):
            x = data[j]
            y = data[i]
            xlabel = labels[j]
            xlim = ranges[j]
            ylabel = labels[i]
            ylim = ranges[i]
            if i==j:
                H, _, _ = ax.hist(x, bins=20, histtype='step', normed=True)
                ax.set_xlim(*xlim)
                ax.set_ylim(0, H.max())
            if i>j:
                if ptype=='hist':
                    ax.hist2d(x, y, bins=20, cmap=cmap)
                if ptype=='scatter':
                    ax.scatter(x, y, s=.4, color=cb)
                ax.set_xlim(*xlim)
                ax.set_ylim(*ylim)
            if i<j:
                ax.axis('off')
            if ax.is_first_col():
                ax.set_ylabel(ylabel, fontsize=5)
            if ax.is_first_col() and i!=0:
                l = ylim[1]-ylim[0]
                ax.set_yticks([ylim[0]+l*.1, ylim[1]-l*.1])
                ax.set_yticklabels(["{:1.1f} ".format(ylim[0]),
                                    " {:1.1f}".format(ylim[1])], fontsize=7)
            else:
                ax.set_yticks([])
            if ax.is_last_row():
                ax.set_xlabel(xlabel, fontsize=5)
                l = xlim[1]-xlim[0]
                ax.set_xticks([xlim[0]+l*.1, xlim[1]-l*.1])
                ax.set_xticklabels(["{:1.1f} ".format(xlim[0]),
                                    " {:1.1f}".format(xlim[1])], fontsize=7)
            else:
                ax.set_xticks([])
    plt.subplots_adjust(wspace=0., hspace=0.)

@plot
def param_prior():
    design, dmin, dmax, labels = load_design(system=('Pb','Pb',2760), pset='main')
    ranges = np.array([dmin, dmax]).T

    nsamples, ndims = design.values.shape
    fig, axes = plt.subplots(nrows=ndims, ncols=ndims, figsize=(10,10))
    corner(design.values.T, axes, ranges, labels, ptype='scatter')
    set_tight(pad=.0, h_pad=.0, w_pad=.0, rect=(.0, 0, 1, 1))

@plot
def etas_prior():
    design, dmin, dmax, labels = load_design(system=('Pb','Pb',2760), pset='main')

    fig, (ax, axt) = plt.subplots(
        nrows=2, ncols=1,
        figsize=(2.8,3), sharex=True, sharey=False
    )
    T = np.linspace(0.0, 0.5, 400)
    for (Tk, al, ah, ek, bpi) in zip(
				design['eta_over_s_T_kink_in_GeV'],
				design['eta_over_s_low_T_slope_in_GeV'],
				design['eta_over_s_high_T_slope_in_GeV'],
				design['eta_over_s_at_kink'],
                design['shear_relax_time_factor']):
        y = eta_over_s(T, Tk, al, ah, ek)
        ax.plot(T, y, 'b-', alpha=0.3)
        axt.plot(T, T*taupi(T, bpi, Tk, al, ah, ek), 'b-', alpha=0.3)
    ax.set_ylabel(r"$\eta/s$")
    ax.set_xticks([0.0, 0.1, 0.2, 0.3, 0.4, 0.5])


    axt.set_xlabel(r"$T$ [GeV]")
    axt.set_ylabel(r"$ T \tau_\pi$")
    axt.set_xticks([0.0, 0.1, 0.2, 0.3, 0.4, 0.5])
    axt.set_ylim(0,15)
    axt.set_xlim(0.1, 0.45)
    axt.annotate(r'$T\tau_\pi = b_\pi \frac{\eta}{s} \frac{T s}{e+p}$', xy=(.5, .7), xycoords="axes fraction", va='center', ha='center')

    ax.annotate(r'$\frac{\eta}{s} = (\eta/s)_{\mathrm{kink}} + a_{\eta,\mathrm{low}}(T-T_{\eta,\mathrm{kink}}), T<T_{\eta,\mathrm{kink}}$', xy=(.5, .9),
 xycoords="axes fraction", va='center', ha='center', fontsize=7)
    ax.annotate(r'$\frac{\eta}{s} = (\eta/s)_{\mathrm{kink}} + a_{\eta,\mathrm{high}}(T-T_{\eta,\mathrm{kink}}), T>T_{\eta,\mathrm{kink}}$', xy=(.5, .75),
 xycoords="axes fraction", va='center', ha='center', fontsize=7)

    set_tight(fig, rect=[0, 0, 1, 1])

@plot
def freestream_prior():
    design, dmin, dmax, labels = load_design(system=('Pb','Pb',2760), pset='main')

    fig, ax = plt.subplots(
        nrows=1, ncols=1,
        figsize=(2.8,2), sharex=True, sharey=False
    )
    e = np.linspace(.2, 25, 100)
    for (t0, a) in zip(
				design['tau_R'],
				design['alpha'],
           ):
        y = tau_fs(e, t0, a)
        ax.plot(e, y, 'b-', alpha=0.3)
    ax.set_xlabel(r"$e/e_0$")
    ax.set_ylabel(r"$\tau_{\mathrm{fs}}$ [fm/$c$]")
    ax.set_xticks([1,5,10,15,20,25])
    ax.set_ylim(0,4)
    ax.set_xlim(0, 25)

    set_tight(fig, rect=[0, 0, 1, 1])



@plot
def zetas_prior():
    design, dmin, dmax, labels = load_design(system=('Pb','Pb',2760), pset='main')

    fig, (ax, axt) = plt.subplots(
        nrows=2, ncols=1,
        figsize=(2.8,3), sharex=True, sharey=False
    )
    T = np.linspace(0.0, 0.5, 100)
    for (zm, T0, w, asym, bPi, q) in zip(
				design['zeta_over_s_max'],
				design['zeta_over_s_T_peak_in_GeV'],
				design['zeta_over_s_width_in_GeV'],
				design['zeta_over_s_lambda_asymm'],
                design['bulk_relax_time_factor'],
                design['bulk_relax_time_power']):
        y = zeta_over_s(T, zm, T0, w, asym)
        ax.plot(T, y, 'b-', alpha=0.3)
        axt.plot(T, tauPi(T, bPi, zm, T0, w, asym, q)/5.026, 'b-', alpha=0.3)
    ax.set_ylabel(r"$\zeta/s$")
    ax.set_xticks([0.0, 0.1, 0.2, 0.3, 0.4, 0.5])
    ax.set_ylim(0,.5)

    axt.set_xlabel(r"$T$ [GeV]")
    axt.set_ylabel(r"$\tau_\Pi$ [fm/$c$]")
    axt.set_xticks([0.0, 0.1, 0.2, 0.3, 0.4, 0.5])
    axt.set_ylim(0,20)
    axt.set_xlim(0.1, 0.45)
    set_tight(fig, rect=[0, 0, 1, 1])

#@plot
def viscous_posterior(plot_samples = False):

    T = np.linspace(0.1, 0.45, 100)

    idf_CI_color = {0 : 'blue', 1 : 'red', 2 : 'green', 3 : 'magenta'}
    color_CI = idf_CI_color[idf]
    if plot_samples:
        color_CI = 'gray'

    if validation:
        v_design, _, _, _ = \
                load_design(system_strs[0], pset='validation')
        tp = v_design.values[validation_pt]
        true_etas = eta_over_s(T, *tp[7:11])
        true_zetas = zeta_over_s(T, *tp[11:15])
    chain = Chain()
    data = chain.load()

    print("data.shape = ")
    print(data.shape)

    index = np.random.choice(np.arange(data.shape[0]), 50000)

    design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')
    samples = data[index, 1:]
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(5,3),
                    sharex=False, sharey=False, constrained_layout=True)
    fig.suptitle("Viscosity Posterior : " + idf_label[idf], fontsize=qm_font_large, wrap=True)

    prior_zetas = []

    n_samples_prior = 100000
    for (zm, T0, w, asym) in zip(
                np.random.uniform( min(design['zeta_over_s_max']), max(design['zeta_over_s_max']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_T_peak_in_GeV']), max(design['zeta_over_s_T_peak_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_width_in_GeV']), max(design['zeta_over_s_width_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_lambda_asymm']), max(design['zeta_over_s_lambda_asymm']), n_samples_prior)
                ):
        prior_zetas.append(zeta_over_s(T, zm, T0, w, asym))

    if not plot_samples:
        axes[0].fill_between(T, np.percentile(prior_zetas, 0, axis=0),
                             np.percentile(prior_zetas, 100, axis=0),
                             color='gray', alpha=0.3, label='100% C.I. (Prior)'
                             )
        axes[0].fill_between(T, np.percentile(prior_zetas, 5, axis=0),
                             np.percentile(prior_zetas, 95, axis=0),
                             color='gray', alpha=0.5, label='90% C.I. (Prior)'
                             )

    if num_systems == 1:
        posterior_zetas = [ zeta_over_s(T, *d[10:14]) for d in samples ]
    elif num_systems == 2:
        posterior_zetas = [ zeta_over_s(T, *d[11:15]) for d in samples ]

    if plot_samples:
        for sample, ls in zip(posterior_zetas[:nsamples], ['-', '--', '-.', ':']):
            axes[0].plot(T, sample, '--', alpha=1.0, lw=1.5, zorder=10, ls=ls, color='red')
    if validation:
        axes[0].plot(T, true_zetas, 'k--')


    axes[0].fill_between(T, np.percentile(posterior_zetas, 5, axis=0),
                            np.percentile(posterior_zetas, 95, axis=0),
                            color=color_CI, alpha=0.4,
                            label='90% Conf. (Posterior)')
    axes[0].fill_between(T, np.percentile(posterior_zetas, 20, axis=0),
                            np.percentile(posterior_zetas, 80, axis=0),
                            color=color_CI, alpha=0.7,
                            label='60% Conf. (Posterior)')

    ##########################
    prior_etas = []

    for (T_k, alow, ahigh, etas_k) in zip(
                np.random.uniform( min(design['eta_over_s_T_kink_in_GeV']), max(design['eta_over_s_T_kink_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_low_T_slope_in_GeV']), max(design['eta_over_s_low_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_high_T_slope_in_GeV']), max(design['eta_over_s_high_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_at_kink']), max(design['eta_over_s_at_kink']), n_samples_prior)
                ):
        prior_etas.append(eta_over_s(T, T_k, alow, ahigh, etas_k))

    if not plot_samples:
        axes[1].fill_between(T, np.percentile(prior_etas, 0, axis=0),
                             np.percentile(prior_etas, 100, axis=0),
                             color='gray', alpha=0.3, label='100% C.I. (Prior)'
                             )
        axes[1].fill_between(T, np.percentile(prior_etas, 5, axis=0),
                             np.percentile(prior_etas, 95, axis=0),
                             color='gray', alpha=0.5, label='90% C.I. (Prior)'
                             )

    if num_systems == 1:
        posterior_etas = [ eta_over_s(T, *d[6:10]) for d in samples ]
    elif num_systems == 2:
        posterior_etas = [ eta_over_s(T, *d[7:11]) for d in samples ]

    if plot_samples:
        for sample, ls in zip(posterior_etas[:nsamples], ['-', '--', '-.', ':']):
            axes[1].plot(T, sample, '--', alpha=1.0, lw=1.5, zorder=10, ls=ls, color='red')
    if validation:
        axes[1].plot(T, true_etas, 'k--')


    axes[1].fill_between(T, np.percentile(posterior_etas, 5, axis=0),
                            np.percentile(posterior_etas, 95, axis=0),
                            color=color_CI, alpha=0.4,
                            label='90% Conf. (Posterior)')
    axes[1].fill_between(T, np.percentile(posterior_etas, 20, axis=0),
                            np.percentile(posterior_etas, 80, axis=0),
                            color=color_CI, alpha=0.7,
                            label='60% Conf. (Posterior)')

    axes[0].legend(fontsize = qm_font_small)

    axes[0].set_ylabel(r"$\zeta/s$")
    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[0].set_ylim(0., 0.35)

    axes[1].set_ylabel(r"$\eta/s$")
    axes[1].set_xlabel(r"$T$ [GeV]")

    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[1].set_xlabel(r"$T$ [GeV]")

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .9])

@plot
def viscous_prior():

    T = np.linspace(0.1, 0.45, 100)

    design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(5,3),
                    sharex=False, sharey=False, constrained_layout=True)
    fig.suptitle("Viscosity Prior", fontsize=qm_font_large, wrap=True)

    prior_zetas = []

    n_samples_prior = 100000
    for (zm, T0, w, asym) in zip(
                np.random.uniform( min(design['zeta_over_s_max']), max(design['zeta_over_s_max']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_T_peak_in_GeV']), max(design['zeta_over_s_T_peak_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_width_in_GeV']), max(design['zeta_over_s_width_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_lambda_asymm']), max(design['zeta_over_s_lambda_asymm']), n_samples_prior)
                ):
        prior_zetas.append(zeta_over_s(T, zm, T0, w, asym))


    axes[0].fill_between(T, np.percentile(prior_zetas, 0, axis=0),
                         np.percentile(prior_zetas, 100, axis=0),
                         color='gray', alpha=0.3, label='100% C.I. (Prior)'
                         )
    axes[0].fill_between(T, np.percentile(prior_zetas, 5, axis=0),
                         np.percentile(prior_zetas, 95, axis=0),
                         color='gray', alpha=0.6, label='90% C.I. (Prior)'
                         )
    axes[0].fill_between(T, np.percentile(prior_zetas, 20, axis=0),
                         np.percentile(prior_zetas, 80, axis=0),
                         color='gray', alpha=0.8, label='60% C.I. (Prior)'
                         )

    ##########################
    prior_etas = []
    for (T_k, alow, ahigh, etas_k) in zip(
                np.random.uniform( min(design['eta_over_s_T_kink_in_GeV']), max(design['eta_over_s_T_kink_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_low_T_slope_in_GeV']), max(design['eta_over_s_low_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_high_T_slope_in_GeV']), max(design['eta_over_s_high_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_at_kink']), max(design['eta_over_s_at_kink']), n_samples_prior)
                ):
        prior_etas.append(eta_over_s(T, T_k, alow, ahigh, etas_k))

    axes[1].fill_between(T, np.percentile(prior_etas, 0, axis=0),
                             np.percentile(prior_etas, 100, axis=0),
                             color='gray', alpha=0.3, label='100% C.I. (Prior)'
                             )
    axes[1].fill_between(T, np.percentile(prior_etas, 5, axis=0),
                             np.percentile(prior_etas, 95, axis=0),
                             color='gray', alpha=0.5, label='90% C.I. (Prior)'
                             )
    axes[1].fill_between(T, np.percentile(prior_etas, 20, axis=0),
                             np.percentile(prior_etas, 80, axis=0),
                             color='gray', alpha=0.7, label='60% C.I. (Prior)'
                             )

    axes[0].legend(fontsize = qm_font_small)

    axes[0].set_ylabel(r"$\zeta/s$")
    axes[0].set_xlabel(r"$T$ [GeV]")
    #axes[0].set_xlim(0.1, 0.4)
    axes[0].set_ylim(0., 0.35)

    axes[1].set_ylabel(r"$\eta/s$")
    axes[1].set_xlabel(r"$T$ [GeV]")
    #axes[1].set_xlim(0.1, 0.4)
    #axes[1].set_ylim(0., 0.55)

    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[1].set_xlabel(r"$T$ [GeV]")

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .9])

@plot
def viscous_posterior_overlay():

    T = np.linspace(0.1, 0.45, 100)

    idf_CI_color = {0 : 'blue', 1 : 'red', 2 : 'green', 3 : 'magenta'}
    color_CI = idf_CI_color[idf]

    chain1 = Chain(path=workdir/'mcmc'/'chain-idf-0_LHC_RHIC_long_chain.hdf'.format(idf))
    data1 = chain1.load_wo_reshape()
    data1 = data1.reshape(-1, 19)

    chain2 = Chain(path=workdir/'mcmc'/'chain-idf-1_LHC_RHIC_long_chain.hdf'.format(idf))
    data2 = chain2.load_wo_reshape()
    data2 = data2.reshape(-1, 19)

    chain3 = Chain(path=workdir/'mcmc'/'chain-idf-3_LHC_RHIC_long_chain.hdf'.format(idf))
    data3 = chain3.load_wo_reshape()
    data3 = data3.reshape(-1, 19)

    print("data1.shape = ")
    print(data1.shape)

    print("data2.shape = ")
    print(data2.shape)

    index1 = np.random.choice(np.arange(data1.shape[0]), 50000)
    index2 = np.random.choice(np.arange(data2.shape[0]), 50000)
    index3 = np.random.choice(np.arange(data3.shape[0]), 50000)

    #design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')
    samples1 = data1[index1, 1:]
    samples2 = data2[index2, 1:]
    samples3 = data3[index3, 1:]

    #the prior density
    design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')

    n_samples_prior = 100000
    prior_zetas = []
    for (zm, T0, w, asym) in zip(
                np.random.uniform( min(design['zeta_over_s_max']), max(design['zeta_over_s_max']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_T_peak_in_GeV']), max(design['zeta_over_s_T_peak_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_width_in_GeV']), max(design['zeta_over_s_width_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_lambda_asymm']), max(design['zeta_over_s_lambda_asymm']), n_samples_prior)
                ):
        prior_zetas.append(zeta_over_s(T, zm, T0, w, asym))

    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(5.5,3.5),
                    sharex=False, sharey=False, constrained_layout=True)
    fig.suptitle(r" Viscosity Posterior", fontsize=qm_font_large, wrap=True)

    posterior_zetas_1 = [ zeta_over_s(T, *d[11:15]) for d in samples1 ]
    posterior_zetas_2 = [ zeta_over_s(T, *d[11:15]) for d in samples2 ]
    posterior_zetas_3 = [ zeta_over_s(T, *d[11:15]) for d in samples3 ]

    axes[0].fill_between(T, np.percentile(prior_zetas, 5, axis=0),
                         np.percentile(prior_zetas, 95, axis=0),
                         color='gray', alpha=0.4, label='90% C.I. (Prior)'
                         )

    axes[0].fill_between(T, np.percentile(posterior_zetas_1, 5, axis=0),
                            np.percentile(posterior_zetas_1, 95, axis=0),
                            edgecolor='blue', lw=2.0, facecolor='None', ls='-',
                            label=r'90% C.I. ' + idf_label_short[0])

    axes[0].fill_between(T, np.percentile(posterior_zetas_2, 5, axis=0),
                            np.percentile(posterior_zetas_2, 95, axis=0),
                            edgecolor='red', lw=2.0, facecolor='None', ls='--',
                            label=r'90% C.I. ' + idf_label_short[1])

    axes[0].fill_between(T, np.percentile(posterior_zetas_3, 5, axis=0),
                            np.percentile(posterior_zetas_3, 95, axis=0),
                            edgecolor='green', lw=2.0, facecolor='None', ls=':',
                            label=r'90% C.I. ' + idf_label_short[3])


    axes[0].legend(loc=(.05, .75), fontsize=qm_font_small)
    ##########################

    posterior_etas_1 = [ eta_over_s(T, *d[7:11]) for d in samples1 ]
    posterior_etas_2 = [ eta_over_s(T, *d[7:11]) for d in samples2 ]
    posterior_etas_3 = [ eta_over_s(T, *d[7:11]) for d in samples3 ]

    prior_etas = []
    for (T_k, alow, ahigh, etas_k) in zip(
                np.random.uniform( min(design['eta_over_s_T_kink_in_GeV']), max(design['eta_over_s_T_kink_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_low_T_slope_in_GeV']), max(design['eta_over_s_low_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_high_T_slope_in_GeV']), max(design['eta_over_s_high_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_at_kink']), max(design['eta_over_s_at_kink']), n_samples_prior)
                ):
        prior_etas.append(eta_over_s(T, T_k, alow, ahigh, etas_k))

    axes[1].fill_between(T, np.percentile(prior_etas, 5, axis=0),
                             np.percentile(prior_etas, 95, axis=0),
                             color='gray', alpha=0.4, label='90% C.I. (Prior)'
                             )

    axes[1].fill_between(T, np.percentile(posterior_etas_1, 5, axis=0),
                            np.percentile(posterior_etas_1, 95, axis=0),
                            edgecolor='blue', lw=2.0, facecolor='None',ls='-')

    axes[1].fill_between(T, np.percentile(posterior_etas_2, 5, axis=0),
                            np.percentile(posterior_etas_2, 95, axis=0),
                            edgecolor='red', lw=2.0, facecolor='None', ls='--')

    axes[1].fill_between(T, np.percentile(posterior_etas_3, 5, axis=0),
                            np.percentile(posterior_etas_3, 95, axis=0),
                            edgecolor='green', lw=2.0, facecolor='None', ls=':')


    axes[0].set_ylabel(r"$\zeta/s$")
    axes[0].set_xlabel(r"$T$ [GeV]")
    #axes[0].set_xticks([0.1, 0.15, 0.2, 0.25, 0.3])
    axes[0].set_ylim(0,.35)

    axes[1].set_ylabel(r"$\eta/s$")
    axes[1].set_xlabel(r"$T$ [GeV]")
    #axes[1].set_xticks([0.1, 0.15, 0.2, 0.25, 0.3])
    #axes[1].set_ylim(0,.55)

    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[1].set_xlabel(r"$T$ [GeV]")

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .9])

@plot
def viscous_posterior_overlay_2():

    T = np.linspace(0.1, 0.45, 100)

    idf_CI_color = {0 : 'blue', 1 : 'red', 2 : 'magenta', 3 : 'green'}
    color_CI = idf_CI_color[idf]

    chain1 = Chain(path=workdir/'mcmc'/'chain-idf-0_LHC_RHIC_long_chain.hdf'.format(idf))
    data1 = chain1.load_wo_reshape()
    data1 = data1.reshape(-1, 19)

    chain2 = Chain(path=workdir/'mcmc'/'chain-idf-0_LHC_RHIC_long_chain_half_PCs.hdf'.format(idf))
    data2 = chain2.load_wo_reshape()
    data2 = data2.reshape(-1, 19)

    #chain3 = Chain(path=workdir/'mcmc'/'chain-idf-0_LHC_RHIC_long_chain_fix_bpi_8.hdf'.format(idf))
    #data3 = chain3.load_wo_reshape()
    #data3 = data3.reshape(-1, 19)

    print("data1.shape = ")
    print(data1.shape)

    print("data2.shape = ")
    print(data2.shape)

    index1 = np.random.choice(np.arange(data1.shape[0]), 50000)
    index2 = np.random.choice(np.arange(data2.shape[0]), 50000)
    #index3 = np.random.choice(np.arange(data3.shape[0]), 50000)

    #design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')
    samples1 = data1[index1, 1:]
    samples2 = data2[index2, 1:]
    #samples3 = data3[index3, 1:]

    #the prior density
    design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')

    n_samples_prior = 100000
    prior_zetas = []
    for (zm, T0, w, asym) in zip(
                np.random.uniform( min(design['zeta_over_s_max']), max(design['zeta_over_s_max']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_T_peak_in_GeV']), max(design['zeta_over_s_T_peak_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_width_in_GeV']), max(design['zeta_over_s_width_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['zeta_over_s_lambda_asymm']), max(design['zeta_over_s_lambda_asymm']), n_samples_prior)
                ):
        prior_zetas.append(zeta_over_s(T, zm, T0, w, asym))

    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(5.5,3.5),
                    sharex=False, sharey=False, constrained_layout=True)
    fig.suptitle(r" Grad Viscosity Posterior : Number of PCs", fontsize=qm_font_large, wrap=True)

    posterior_zetas_1 = [ zeta_over_s(T, *d[11:15]) for d in samples1 ]
    posterior_zetas_2 = [ zeta_over_s(T, *d[11:15]) for d in samples2 ]
    #posterior_zetas_3 = [ zeta_over_s(T, *d[11:15]) for d in samples3 ]

    axes[0].fill_between(T, np.percentile(prior_zetas, 5, axis=0),
                         np.percentile(prior_zetas, 95, axis=0),
                         color='gray', alpha=0.4, label='90% C.I. (Prior)'
                         )

    axes[0].fill_between(T, np.percentile(posterior_zetas_1, 5, axis=0),
                            np.percentile(posterior_zetas_1, 95, axis=0),
                            edgecolor=color_CI, lw=2.0, facecolor='None', ls='-',
                            label='90% C.I. 10 PCs Pb, \n 6 PCs Au')

    axes[0].fill_between(T, np.percentile(posterior_zetas_2, 5, axis=0),
                            np.percentile(posterior_zetas_2, 95, axis=0),
                            edgecolor=color_CI, lw=2.0, facecolor='None', ls='--',
                            label='90% C.I. 5 PCs Pb, \n 3 PCs Au' )

    #axes[0].fill_between(T, np.percentile(posterior_zetas_3, 5, axis=0),
    #                        np.percentile(posterior_zetas_3, 95, axis=0),
    #                        edgecolor=color_CI, lw=2.0, facecolor='None', ls=':',
    #                        label=r'90% C.I. $b_{\pi} = 8$' )


    axes[0].legend(loc=(.05, .75), fontsize=qm_font_small)
    ##########################

    posterior_etas_1 = [ eta_over_s(T, *d[7:11]) for d in samples1 ]
    posterior_etas_2 = [ eta_over_s(T, *d[7:11]) for d in samples2 ]
    #posterior_etas_3 = [ eta_over_s(T, *d[7:11]) for d in samples3 ]

    prior_etas = []
    for (T_k, alow, ahigh, etas_k) in zip(
                np.random.uniform( min(design['eta_over_s_T_kink_in_GeV']), max(design['eta_over_s_T_kink_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_low_T_slope_in_GeV']), max(design['eta_over_s_low_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_high_T_slope_in_GeV']), max(design['eta_over_s_high_T_slope_in_GeV']), n_samples_prior),
                np.random.uniform( min(design['eta_over_s_at_kink']), max(design['eta_over_s_at_kink']), n_samples_prior)
                ):
        prior_etas.append(eta_over_s(T, T_k, alow, ahigh, etas_k))

    axes[1].fill_between(T, np.percentile(prior_etas, 5, axis=0),
                             np.percentile(prior_etas, 95, axis=0),
                             color='gray', alpha=0.4)

    axes[1].fill_between(T, np.percentile(posterior_etas_1, 5, axis=0),
                            np.percentile(posterior_etas_1, 95, axis=0),
                            edgecolor=color_CI, lw=2.0, facecolor='None',ls='-')

    axes[1].fill_between(T, np.percentile(posterior_etas_2, 5, axis=0),
                            np.percentile(posterior_etas_2, 95, axis=0),
                            edgecolor=color_CI, lw=2.0, facecolor='None', ls='--')

    #axes[1].fill_between(T, np.percentile(posterior_etas_3, 5, axis=0),
    #                        np.percentile(posterior_etas_3, 95, axis=0),
    #                        edgecolor=color_CI, lw=2.0, facecolor='None', ls=':')

    axes[0].set_ylabel(r"$\zeta/s$")
    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[0].set_ylim(0,.35)

    axes[1].set_ylabel(r"$\eta/s$")
    axes[1].set_xlabel(r"$T$ [GeV]")

    axes[0].set_xlabel(r"$T$ [GeV]")
    axes[1].set_xlabel(r"$T$ [GeV]")

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .9])

@plot
def viscous_posterior_w_samples():
    viscous_posterior(plot_samples=True)
@plot
def viscous_posterior_wo_samples():
    viscous_posterior(plot_samples=False)


@plot
def freestream_time_posterior_overlay():

    e = np.linspace(1e-1, 1e1, 1000)

    idf_CI_color = {0 : 'blue', 1 : 'red', 2 : 'green', 3 : 'magenta'}
    color_CI = idf_CI_color[idf]

    chain1 = Chain(path=workdir/'mcmc'/'chain-idf-0_LHC_RHIC_long_chain.hdf')
    data1 = chain1.load_wo_reshape()
    data1 = data1.reshape(-1, 19)

    chain2 = Chain(path=workdir/'mcmc'/'chain-idf-1_LHC_RHIC_long_chain.hdf')
    data2 = chain2.load_wo_reshape()
    data2 = data2.reshape(-1, 19)

    chain3 = Chain(path=workdir/'mcmc'/'chain-idf-3_LHC_RHIC_long_chain.hdf')
    data3 = chain3.load_wo_reshape()
    data3 = data3.reshape(-1, 19)

    print("data1.shape = ")
    print(data1.shape)

    print("data2.shape = ")
    print(data2.shape)

    index1 = np.random.choice(np.arange(data1.shape[0]), 50000)
    index2 = np.random.choice(np.arange(data2.shape[0]), 50000)
    index3 = np.random.choice(np.arange(data3.shape[0]), 50000)

    #design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')
    samples1 = data1[index1, 1:]
    samples2 = data2[index2, 1:]
    samples3 = data3[index3, 1:]

    #the prior density
    design, dmin, dmax, labels = load_design(system_str=system_strs[0], pset='main')

    n_samples_prior = 100000
    prior_tau_fs = []
    for (tau_R, alpha) in zip(
                np.random.uniform( min(design['tau_R']), max(design['tau_R']), n_samples_prior),
                np.random.uniform( min(design['alpha']), max(design['alpha']), n_samples_prior),
                ):
        prior_tau_fs.append(tau_fs(e, tau_R, alpha))

    #fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(5.5,3.5), sharex=False, sharey=False, constrained_layout=True)
    fig = plt.figure(figsize=(4,4))
    plt.suptitle(r"Freestreaming Time Posterior", fontsize=qm_font_large, wrap=True)

    posterior_tau_fs_1 = [ tau_fs(e, *d[5:7]) for d in samples1 ]
    posterior_tau_fs_2 = [ tau_fs(e, *d[5:7]) for d in samples2 ]
    posterior_tau_fs_3 = [ tau_fs(e, *d[5:7]) for d in samples3 ]

    plt.fill_between(e, np.percentile(prior_tau_fs, 5, axis=0),
                         np.percentile(prior_tau_fs, 95, axis=0),
                         color='gray', alpha=0.4, label='90% C.I. (Prior)'
                         )

    plt.fill_between(e, np.percentile(posterior_tau_fs_1, 5, axis=0),
                            np.percentile(posterior_tau_fs_1, 95, axis=0),
                            edgecolor='blue', lw=2.0, facecolor='None', ls='-',
                            label=r'90% C.I. ' + idf_label_short[0])

    plt.fill_between(e, np.percentile(posterior_tau_fs_2, 5, axis=0),
                            np.percentile(posterior_tau_fs_2, 95, axis=0),
                            edgecolor='red', lw=2.0, facecolor='None', ls='--',
                            label=r'90% C.I. ' + idf_label_short[1])

    plt.fill_between(e, np.percentile(posterior_tau_fs_3, 5, axis=0),
                            np.percentile(posterior_tau_fs_3, 95, axis=0),
                            edgecolor='green', lw=2.0, facecolor='None', ls=':',
                            label=r'90% C.I. ' + idf_label_short[3])


    plt.legend(loc='upper center', fontsize=qm_font_small)
    plt.ylabel(r"$\tau_{FS}$ [fm/c]")
    plt.xlabel(r"$e_0 / e_R$")
    plt.ylim(0, 3.5)

    plt.tight_layout(True)
    set_tight(fig, rect=[0, 0, 1, .9])

@plot
def zetas_validation():
    # prior
    design,_,_,_ = load_design(system_strs[0], pset='main')
    T = np.linspace(0.13, 0.37, 500)
    #prior = np.array([zeta_over_s(T, *truth) for truth in design[11:14]])
    prior = np.array([zeta_over_s(T, X[11], X[12], X[13], X[14]) for X in design.values])


    fig, axes = plt.subplots(
        nrows=5, ncols=5,
        figsize=(6,6), sharex=True, sharey=True
    )

    # validation
    #design, _, _, _ = prepare_emu_design(systems[0],pset='validation')
    design,_,_,_ = load_design(system_strs[0], pset='validation')
    #for iv, ax in zip(np.random.choice(range(93),25), axes.flatten()):
    for iv, ax in zip([0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17], axes.flatten()):
        f = "./validate/{:d}-zetas.dat".format(iv)
        t, m, M, l1, l2, h1, h2 = np.loadtxt(f).T

        X=design.values[iv]

        #true = zeta_over_s(T, *design[iv])
        true = zeta_over_s(T, X[11], X[12], X[13], X[14])
        ax.plot(T, true, ls="--", c=".3", linewidth=2)
        Ttest = t #[.155, .175, .2, .25, .35]
        #ax.errorbar(Ttest, M, yerr=[M-l1,h2-M], color=cr,fmt='o', linewidth=.5)
        ax.fill_between(Ttest, l1, h2, color='blue', alpha=.2)
        ax.fill_between(Ttest, l2, h1, color='blue', alpha=.4)
        ax.annotate(r"$\tau_{\pi}: $"+r"${:1.1f}$".format(X[15]),xy=(.3, .9), xycoords="axes fraction")
        ax.annotate(r"$\tau_0: $"+r"${:1.2f}$".format(X[5]),xy=(.3, .75), xycoords="axes fraction")
        ax.annotate(r"$\alpha: $"+r"${:1.2f}$".format(X[6]),xy=(.3, .6), xycoords="axes fraction")
        ax.annotate(r"$\sigma: $"+r"${:1.3f}$".format(X[2]),xy=(.3, .45), xycoords="axes fraction")

        #for iT, im, iy1, iy2 in zip(Ttest, M,l2,h1):
        #    ax.fill_between([iT-.01, iT+.01], [iy1, iy1], [iy2, iy2], edgecolor=cr, linewidth=.5, facecolor='none')

        ax.fill_between(T, np.min(prior, axis=0), np.max(prior, axis=0), color='gray', alpha=.1)
        if ax.is_last_row():
            ax.set_xlabel(r"$T$ [GeV]")
        if ax.is_first_col():
            ax.set_ylabel(r"$\zeta/s$")

    ax.set_xticks([0.15, 0.25,  0.35])
    ax.set_xticklabels([0.15, 0.25, 0.35])
    set_tight(fig, rect=[0, 0, 1, 1])

@plot
def etas_validation():
    # prior
    design,_,_,_ = load_design(system_strs[0], pset='main')
    T = np.linspace(0.13, 0.37, 500)
    prior = np.array([eta_over_s(T, X[7], X[8], X[9], X[10]) for X in design.values])


    fig, axes = plt.subplots(
        nrows=5, ncols=5,
        figsize=(6,6), sharex=True, sharey=True
    )

    # validation
    #design, _, _, _ = prepare_emu_design(systems[0],pset='validation')
    design,_,_,_ = load_design(system_strs[0], pset='validation')
    #for iv, ax in zip(np.random.choice(range(93),25), axes.flatten()):
    for iv, ax in zip([0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17], axes.flatten()):
        f = "./validate/{:d}-etas.dat".format(iv)
        t, m, M, l1, l2, h1, h2 = np.loadtxt(f).T

        X=design.values[iv]

        #true = zeta_over_s(T, *design[iv])
        true = eta_over_s(T, X[7], X[8], X[9], X[10])
        ax.plot(T, true, ls="--", c=".3", linewidth=2)
        Ttest = t #[.155, .175, .2, .25, .35]
        #ax.errorbar(Ttest, M, yerr=[M-l1,h2-M], color=cr,fmt='o', linewidth=.5)
        ax.fill_between(Ttest, l1, h2, color='blue', alpha=.2)
        ax.fill_between(Ttest, l2, h1, color='blue', alpha=.4)
        #for iT, im, iy1, iy2 in zip(Ttest, M,l2,h1):
        #    ax.fill_between([iT-.01, iT+.01], [iy1, iy1], [iy2, iy2], edgecolor=cr, linewidth=.5, facecolor='none')
        ax.annotate(r"$\tau_{\pi}: $"+r"${:1.1f}$".format(X[15]),xy=(.3, .9), xycoords="axes fraction")
        ax.annotate(r"$\tau_0: $"+r"${:1.2f}$".format(X[5]),xy=(.3, .75), xycoords="axes fraction")
        ax.annotate(r"$\alpha: $"+r"${:1.2f}$".format(X[6]),xy=(.3, .6), xycoords="axes fraction")
        ax.annotate(r"$\sigma: $"+r"${:1.3f}$".format(X[2]),xy=(.3, .45), xycoords="axes fraction")

        ax.fill_between(T, np.min(prior, axis=0), np.max(prior, axis=0), color='gray', alpha=.1)
        if ax.is_last_row():
            ax.set_xlabel(r"$T$ [GeV]")
        if ax.is_first_col():
            ax.set_ylabel(r"$\eta/s$")

    ax.set_xticks([0.15, 0.25,  0.35])
    ax.set_xticklabels([0.15, 0.25, 0.35])
    set_tight(fig, rect=[0, 0, 1, 1])

@plot
def validate_extraction():
    import glob
    true = []
    mid = []
    maxi = []
    L1 = []
    L2 = []
    H1 = []
    H2 = []
    for f in glob.glob("./validate/*"):
        t, m, M, l1, l2, h1, h2 = np.loadtxt(f).T
        true.append(t)
        mid.append(m)
        maxi.append(M)
        L1.append(l1)
        L2.append(l2)
        H1.append(h1)
        H2.append(h2)
    true = np.array(true)
    mid = np.array(mid)
    maxi = np.array(maxi)
    L1 = np.array(L1)
    L2 = np.array(L2)
    H1 = np.array(H1)
    H2 = np.array(H2)
    labels = [r'$N_{2.76\mathrm{TeV}}$',r'$k$', r'$w$ [fm]', r'$\tau_R$ [fm/$c$]',
              r'$\alpha$', r'$\eta/s$', r'$(\zeta/s)_{\max}$',
              r'$T_{\zeta/s}^{\mathrm{peak}}$ [GeV]', r'$A^{1/4}_{\zeta/s}$',
              r'$\lambda^{asym}_{\zeta/s}$']
    # get range
    range_file = design_dir + \
               '/design_ranges_main_{:s}{:s}-{:d}.dat'.format(*systems[0])
    design_range = pd.read_csv(range_file)
    design_max = design_range['max'].values
    design_min = design_range['min'].values

    fig, axes = plt.subplots(
        nrows=3, ncols=5,
        figsize=(8,5),
    )

    for i, (label, ax) in enumerate(zip(labels, axes.flatten())):
        ax.errorbar(true[:,i], mid[:,i], yerr=[mid[:,i]-L2[:,i],H2[:,i]-mid[:,i]], color=cr,fmt='o', linewidth=.1)
        ax.errorbar(true[:,i], mid[:,i], yerr=[mid[:,i]-L1[:,i],H1[:,i]-mid[:,i]], color=cr,fmt='o', linewidth=.5)
        ax.scatter(true[:,i], maxi[:,i], color=cb)
        cov = np.cov(np.stack((true[:,i], mid[:,i]), axis=0))
        #label = label+r", $r = {:1.2f}$".format(cov[1,0]/np.sqrt(cov[0,0]*cov[1,1]))
        ax.set_title(label)
        if ax.is_last_row():
            ax.set_xlabel("Truth")
        if ax.is_first_col():
            ax.set_ylabel("Extracted")
        ax.plot([design_min[i],design_max[i]], [design_min[i],design_max[i]], ls="--", c=".3")
        ax.set_aspect('equal')



    for ax, Ttest, i in zip(axes[2], [.155, .175, .2, .25, .35], [10,11,12,13,14]):
        ax.errorbar(true[:,i], mid[:,i], yerr=[mid[:,i]-L2[:,i],H2[:,i]-mid[:,i]], color=cr,fmt='o', linewidth=.1)
        ax.errorbar(true[:,i], mid[:,i], yerr=[mid[:,i]-L1[:,i],H1[:,i]-mid[:,i]], color=cr,fmt='o', linewidth=.5)
        ax.scatter(true[:,i], maxi[:,i], color=cb)
        ax.set_title(r"$\zeta/s$"+r"$(T={:1.3f})$".format(Ttest))
        if ax.is_last_row():
            ax.set_xlabel("Truth")
        if ax.is_first_col():
            ax.set_ylabel("Extracted")
        ax.plot([0,0.25], [0,0.25], ls="--", c=".3")
    set_tight(fig, rect=[0, 0, 1, 1])


@plot
def find_map():
    """
    Find the maximum a posteriori (MAP) point and compare emulator predictions
    to experimental data.

    """
    from scipy.optimize import minimize
    from scipy.optimize import basinhopping

    chain = Chain()

    fixed_params = {
        #'trento_p': 0.,
        #'etas_min': .08,
        #'etas_hrg': .3,
        #'model_sys_err': .1,
    }

    #opt_params = [k for k in chain.keys if k not in fixed_params]
    opt_params = [k for k in chain.labels if k not in fixed_params]

    def full_x(x):
        x = dict(zip(opt_params, x), **fixed_params)
        #return [x[k] for k in chain.keys]
        return [x[k] for k in chain.labels]

    print("Minimizing -log(Posterior) to find MAP parameters...")
    bounds=[
        (a + 1e-6*(b - a), b - 1e-6*(b - a))
        for (a, b), k in zip(chain.range, chain.labels)
        if k in opt_params
    ]
    #minimizer_kwargs = dict(method="L-BFGS-B", bounds=bounds)
    x0 = np.median(chain.load(), axis=0)
    #res = basinhopping(
    #        lambda x: -chain.log_posterior(full_x(x))[0],
    #        x0,
    #        minimizer_kwargs=minimizer_kwargs
    #        )
    #NOTE scipy.optimize minimize finds local minima not global minima
    res = minimize(
        lambda x: -chain.log_posterior(full_x(x))[0],
        x0 = x0,
        tol = 1e-8,
        bounds=bounds
        )

    print('optimization result:\n%s', res)
    #width = max(map(len, chain.keys)) + 2
    width = max(map(len, chain.labels)) + 2
    print(
        'MAP params:\n%s',
        '\n'.join(
            #k.ljust(width) + str(x) for k, x in zip(chain.keys, full_x(res.x))
            k.ljust(width) + str(x) for k, x in zip(chain.labels, full_x(res.x))
        )
    )
    systems_title = ''
    for s in system_strs:
        systems_title += (' ' + s)
    with open('plots/MAP_' + idf_label[idf] + '.md', 'w') as myfile:
        myfile.write('## MAP parameters : ' + idf_label_short[idf] + ' ' + systems_title + '\n')
        myfile.write('| Parameter | MAP Value |\n')
        myfile.write('| --------- | --------- |\n')
        myfile.write(
            '\n'.join(
                #k.ljust(width) + str(x) for k, x in zip(chain.keys, full_x(res.x))
                '|'+k+'|'+str(round(x, 3))+'|' for k, x in zip(chain.labels, full_x(res.x))
            )
        )

    """
    pred = chain._predict(np.atleast_2d(full_x(res.x)))

    plots = _observables_plots()

    fig, axes = plt.subplots(
        nrows=2*len(plots), ncols=len(systems),
        figsize=figsize(1.1, aspect=1.7),
        gridspec_kw=dict(
            height_ratios=list(itertools.chain.from_iterable(
                (p.get('height_ratio', 1), .4) for p in plots
            ))
        )
    )

    for (plot, system), ax, ratio_ax in zip(
            itertools.product(plots, systems), axes[::2].flat, axes[1::2].flat
    ):
        for obs, subobs, opts in plot['subplots']:
            color = obs_color(obs, subobs)
            scale = opts.get('scale')

            x = model.data[system][obs][subobs]['x']
            y = pred[system][obs][subobs][0]

            if scale is not None:
                y = y*scale

            ax.plot(x, y, color=color)

            if 'label' in opts:
                ax.text(
                    x[-1] + 3, y[-1],
                    opts['label'],
                    color=darken(color), ha='left', va='center'
                )

            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                continue

            x = dset['x']
            yexp = dset['y']
            yerr = dset['yerr']
            yerrstat = yerr.get('stat')
            yerrsys = yerr.get('sys', yerr.get('sum'))

            if scale is not None:
                yexp = yexp*scale
                if yerrstat is not None:
                    yerrstat = yerrstat*scale
                if yerrsys is not None:
                    yerrsys = yerrsys*scale

            ax.errorbar(
                x, yexp, yerr=yerrstat, fmt='o',
                capsize=0, color='.25', zorder=1000
            )

            ax.fill_between(
                x, yexp - yerrsys, yexp + yerrsys,
                color='.9', zorder=-10
            )

            ratio_ax.plot(x, y/yexp, color=color)

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        for a in [ax, ratio_ax]:
            a.set_xlim(0, 80)
            auto_ticks(a, 'x', nbins=5, minor=2)

        ax.set_xticklabels([])

        ax.set_ylim(plot['ylim'])

        if ax.is_first_row():
            ax.set_title(format_system(system))
        elif ax.is_last_row():
            ax.set_xlabel('Centrality %')

        if ax.is_first_col():
            ax.set_ylabel(plot['ylabel'])

        if ax.is_last_col():
            ax.text(
                1.02, .5, plot['title'],
                transform=ax.transAxes, ha='left', va='center',
                size=plt.rcParams['axes.labelsize'], rotation=-90
            )

        ratio_ax.axhline(1, lw=.5, color='0.5', zorder=-100)
        ratio_ax.axhspan(0.9, 1.1, color='0.95', zorder=-200)
        ratio_ax.set_ylim(0.8, 1.2)
        ratio_ax.set_yticks(np.arange(80, 121, 20)/100)
        ratio_ax.set_ylabel('Ratio')

    set_tight(fig, rect=[0, 0, .97, 1])
    """


def format_ci(samples, ci=.9):
    """
    Compute the median and a credible interval for an array of samples and
    return a TeX-formatted string.

    """
    cil, cih = credible_interval(samples, ci=ci)
    median = np.median(samples)
    ul = median - cil
    uh = cih - median

    # decide precision for formatting numbers
    # this is NOT general but it works for the present data
    if abs(median) < .05 or (uh + ul) < abs(median) < .5:
        precision = 3
    elif abs(median) < 5:
        precision = 2
    else:
        precision = 1

    fmt = str(precision).join(['{:#.', 'f}'])

    return ''.join([
        '$', fmt.format(median),
        '_{-', fmt.format(ul), '}',
        '^{+', fmt.format(uh), '}$'
    ])


def _posterior():
    chain = Chain()
    labels = chain.labels
    ranges = chain.range

    #indices = [0, 1, 2, 3, 4, 6, 7, 17]
    indices = [8, 9, 10, 11, 16]

    chain0 = Chain(path=workdir/'mcmc'/'sensitivity'/'chain_base_2-idf-0.hdf')
    data0 = chain0.load().T

    chain1 = Chain(path=workdir/'mcmc'/'sensitivity'/'chain_base_3-idf-0.hdf')
    data1 = chain1.load().T

    data0 = np.take(data0, indices, axis=0)
    data1 = np.take(data1, indices, axis=0)

    labels = np.take(labels, indices)
    ranges = np.take(ranges, indices)
    ndims, nsamples = data0.shape

    ranges = np.array([np.min(data0, axis=1), np.max(data0, axis=1)]).T

    cmap0 = plt.get_cmap('Blues')
    cmap1 = plt.get_cmap('Reds')
    cmap0.set_bad('white')
    cmap1.set_bad('white')

    fig, axes = plt.subplots(
        nrows=ndims, ncols=ndims,
        figsize=(.7*ndims, .7*ndims)
    )

    for i, row in enumerate(axes):
        for j, ax in enumerate(row):
            x0 = data0[j]
            y0 = data0[i]
            x1 = data1[j]
            y1 = data1[i]
            xlabel = labels[j]
            xlim = ranges[j]
            ylabel = labels[i]
            ylim = ranges[i]
            if i==j:
                H0, _, _ = ax.hist(x0, bins=40, histtype='step', normed=True, color='blue')
                H1, _, _ = ax.hist(x1, bins=40, histtype='step', normed=True, color='red')
                stex0 = format_ci(x0)
                stex1 = format_ci(x1)
                ax.annotate(stex0, xy=(0.1, 1.), xycoords="axes fraction", ha='center', va='bottom', fontsize=5, color='blue')
                ax.annotate(stex1, xy=(.9, 1.), xycoords="axes fraction", ha='center', va='bottom', fontsize=5, color='red')
                ax.set_xlim(*xlim)
                #if i < ndims-1:
                #    ax.axvline(x=truth[i], color='r')
                ax.set_ylim(0, max(H0.max(), H1.max()))
            if i>j:
                ax.hist2d(x0, y0, bins=40, cmap=cmap0, alpha=0.8, zorder=1)
                ax.hist2d(x1, y1, bins=40, cmap=cmap1, alpha=0.4, zorder=1)
                ax.set_xlim(*xlim)
                ax.set_ylim(*ylim)
            if i<j:
                ax.axis('off')
            if ax.is_first_col():
                ax.set_ylabel(ylabel, fontsize=5)
            if ax.is_first_col() and i!=0:
                l = ylim[1]-ylim[0]
                ax.set_yticks([ylim[0]+l*.1, ylim[1]-l*.1])
                ax.set_yticklabels(["{:1.2f} ".format(ylim[0]), " {:1.2f}".format(ylim[1])], fontsize=5)
            else:
                ax.set_yticks([])
            if ax.is_last_row():
                ax.set_xlabel(xlabel, fontsize=5)
                l = xlim[1]-xlim[0]
                ax.set_xticks([xlim[0]+l*.1, xlim[1]-l*.1])
                ax.set_xticklabels(["{:1.2f} ".format(xlim[0]),
                                    " {:1.2f}".format(xlim[1])], fontsize=5)
            else:
                ax.set_xticks([])
    #        plt.subplots_adjust(wspace=0., hspace=0.)
    fig.align_ylabels()
    set_tight(pad=.0, h_pad=.0, w_pad=.0, rect=(.01, 0, 1, 1))

def _posterior_diag():

    chain = Chain()

    if validation:
        truths = []
        #get VALIDATION points
        for s in system_strs:
            v_design, _, _, _ = \
                load_design(s, pset='validation')
            truths.append(v_design.values[validation_pt,0])
        truths = truths + list(v_design.values[validation_pt,1:]) + [-1]


        labels = chain.labels
        ranges = chain.range
        data = chain.load().T
        ndims, nsamples = data.shape


        cmap = plt.get_cmap('Blues')
        cmap.set_bad('white')

        fig, axes = plt.subplots(nrows=4, ncols=5, figsize=(8, 6) )
        fig.suptitle("Parameters Posterior : " + idf_label[idf] + " Visc. Correction ")

        for ax, x, xlabel, xlim, truth in zip(axes.flatten(), data, labels, ranges, truths):

                H, _, _ = ax.hist(x, bins=21, histtype='step', density=True)

                stex = format_ci(x)
                ax.annotate(stex, xy=(.75, .8), xycoords="axes fraction", ha='center', va='bottom', fontsize=6)
                ax.set_xlim(*xlim)
                ax.axvline(x=truth, color='r')
                ax.set_ylim(0, H.max()*1.25)
                ax.set_yticks([])

                ax.annotate(xlabel, xy=(.25, .8), xycoords="axes fraction", ha='center', va='bottom', fontsize=6)
                l = xlim[1]-xlim[0]
                ax.set_xticks([xlim[0]+l*.05, (xlim[0]+xlim[1])/2., xlim[1]-l*.05])
                ax.set_xticklabels(["{:1.2f} ".format(xlim[0]),
                                    "{:1.2f} ".format((xlim[0]+xlim[1])/2.),
                                    " {:1.2f}".format(xlim[1])], fontsize=6)

                plt.subplots_adjust(wspace=0.05, hspace=0.1)
        #set_tight(pad=.0, h_pad=.1, w_pad=.05, rect=(.01, 0, 1, .9))
        plt.tight_layout(True)
        set_tight(fig, rect=[0, 0, 1, .9])

    else :
        labels = chain.labels
        ranges = chain.range
        data = chain.load().T
        ndims, nsamples = data.shape
        ranges = np.array([np.min(data, axis=1), np.max(data, axis=1)]).T

        cmap = plt.get_cmap('Blues')
        cmap.set_bad('white')

        fig, axes = plt.subplots(nrows=4, ncols=5, figsize=(6, 4.5) )

        for ax, x, xlabel, xlim in zip(axes.flatten(), data, labels, ranges):

                H, _, _ = ax.hist(x, bins=21, histtype='step', density=True)

                stex = format_ci(x)
                ax.annotate(stex, xy=(.75, .8), xycoords="axes fraction", ha='center', va='bottom', fontsize=6)
                ax.set_xlim(*xlim)
                ax.set_ylim(0, H.max()*1.25)
                ax.set_yticks([])
                ax.annotate(xlabel, xy=(.25, .8), xycoords="axes fraction", ha='center', va='bottom', fontsize=6)
                l = xlim[1]-xlim[0]
                ax.set_xticks([xlim[0]+l*.05, (xlim[0]+xlim[1])/2., xlim[1]-l*.05])
                ax.set_xticklabels(["{:1.2f} ".format(xlim[0]),
                                    "{:1.2f} ".format((xlim[0]+xlim[1])/2.),
                                    " {:1.2f}".format(xlim[1])], fontsize=6)

                plt.subplots_adjust(wspace=0.05, hspace=0.1)
        set_tight(pad=.0, h_pad=.1, w_pad=.05, rect=(.01, 0, 1, 1))




@plot
def posterior():
    _posterior()

@plot
def diag_posterior():
    _posterior_diag()


@plot
def posterior_shear():
    _posterior(
        scale=1.35, pad_subplots=.1, rect_t=.97,
        params={'etas_min', 'etas_slope', 'etas_crv'}
    )

def _region(ax, name, cmap=plt.cm.Blues, legend=False, title=False):
    """
    Visual estimate (posterior median and credible region) of
    temperature-dependent shear or bulk viscosity.

    """
    var, keys, function, ymax = dict(
        shear=(
            'eta',
            ['min', 'slope', 'crv'],
            lambda T, m, s, c: m + s*(T - Tc)*(T/Tc)**c,
            .4
        ),
        bulk=(
            'zeta',
            ['max', 'width', 't0'],
            lambda T, m, w, T0: m / (1 + ((T - T0)/w)**2),
            .08
        ),
    )[name]

    Tmin, Tmax = .150, .300
    Tc = .154

    samples = mcmc.Chain().load(*['{}s_{}'.format(var, k) for k in keys])

    T = np.linspace(Tc if name == 'shear' else Tmin, Tmax, 1000)
    ax.plot(
        T, function(T, *np.median(samples, axis=0)),
        color=cmap(.75), label='Posterior median'
    )

    Tsparse = np.linspace(T[0], T[-1], 25)
    intervals = [
        PchipInterpolator(Tsparse, y)(T)
        for y in np.array([
            mcmc.credible_interval(function(t, *samples.T))
            for t in Tsparse
        ]).T
    ]
    ax.fill_between(
        T, *intervals,
        color=cmap(.3), label='90% credible region'
    )

    ax.set_xlim(Tmin, Tmax)
    ax.set_ylim(0, ymax)
    auto_ticks(ax, nbins=5)
    ax.xaxis.set_major_formatter(
        ticker.FuncFormatter(lambda x, pos: int(1000*x))
    )

    ax.set_xlabel('Temperature [MeV]')
    ax.set_ylabel(r'$\{}/s$'.format(var))

    if title:
        ax.set_title(name.capitalize() + ' viscosity')

    if legend:
        ax.legend(loc=legend if isinstance(legend, str) else 'best')

    if name == 'shear':
        ax.axhline(
            1/(4*np.pi),
            color='.5', linewidth=plt.rcParams['ytick.major.width']
        )
        ax.text(Tmax, .07, r'$1/4\pi$', va='top', ha='right', color='.3')


@plot
def region_shear():
    """
    Region plot for eta/s.

    """
    fig, ax = plt.subplots(figsize=figsize(.65))
    _region(ax, 'shear', legend='upper left')


@plot
def design():
    """
    Projection of a LH design into two dimensions.

    """
    fig = plt.figure(figsize=figsize(.6, aspect=1))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    d = Design(systems[0])

    keys = ('etas_min', 'etas_slope')
    indices = tuple(d.keys.index(k) for k in keys)

    x, y = (d.array[:, i] for i in indices)
    ax_j.plot(x, y, 'o', color=plt.cm.Blues(0.75), mec='white', mew=.3)

    hist_kw = dict(bins=30, color=plt.cm.Blues(0.4), edgecolor='white', lw=.5)
    ax_x.hist(x, **hist_kw)
    ax_y.hist(y, orientation='horizontal', **hist_kw)

    for ax in fig.axes:
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)

    auto_ticks(ax_j, nbins=4)

    for ax in ax_x, ax_y:
        ax.tick_params(
            bottom=False, left=False,
            labelbottom=False, labelleft=False
        )

    for i, xy in zip(indices, 'xy'):
        for f, l in [('lim', d.range), ('label', d.labels)]:
            getattr(ax_j, 'set_{}{}'.format(xy, f))(l[i])


@plot
def gp():
    """
    Conditioning a Gaussian process.

    """
    fig, axes = plt.subplots(
        figsize=figsize(.6, aspect=1.35),
        nrows=2, sharex='col'
    )

    gp = GPR(1.*kernels.RBF(.8), optimizer=None)

    x = np.linspace(0, 5, 1000)
    X = x[:, np.newaxis]

    x_train = np.linspace(.5, 4.5, 4)
    X_train = x_train[:, np.newaxis]

    for title, ax in zip(['Random functions', 'Conditioned on data'], axes):
        if title.startswith('Conditioned'):
            y = gp.sample_y(X_train, random_state=23158).squeeze()
            y -= .5*(y.max() + y.min())
            gp.fit(X_train, y)
            training_data, = plt.plot(
                x_train, y, 'o',
                markersize=1.4*plt.rcParams['lines.markersize'],
                color='.3', zorder=50
            )

        for s, c in zip(
                gp.sample_y(X, n_samples=4, random_state=34576).T,
                ['Blues', 'Greens', 'Oranges', 'Purples']
        ):
            ax.plot(x, s, color=getattr(plt.cm, c)(.6))

        mean, std = gp.predict(X, return_std=True)
        std = ax.fill_between(x, mean - std, mean + std, color='.92')
        mean, = ax.plot(x, mean, color='.42', linestyle='dashed')

        ax.set_xlim(x[0], x[-1])
        ax.set_ylim(-2, 2)
        ax.set_ylabel('Output')
        auto_ticks(ax, nbins=5)

        ax.set_title(title, y=.9)

    ax.set_xlabel('Input')
    ax.legend(*zip(*[
        (mean, 'Mean prediction'),
        (std, 'Uncertainty'),
        (training_data, 'Training data'),
    ]), loc='lower left')

    set_tight(fig, h_pad=1)


@plot
def pca():
    fig = plt.figure(figsize=figsize(.6, aspect=1))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    x, y = (
        model.data['PbPb2760'][obs][subobs]['Y'][:, 3]
        for obs, subobs in [('dN_dy', 'pion'), ('vnk', (2, 2))]
    )
    xlabel = r'$dN_{\pi^\pm}/dy$'
    ylabel = r'$v_2\{2\}$'
    xlim = 0, 1400
    ylim = 0, 0.15

    cmap = plt.cm.Blues

    ax_j.plot(x, y, 'o', color=cmap(.75), mec='white', mew=.25, zorder=10)

    for d, ax, orientation in [(x, ax_x, 'vertical'), (y, ax_y, 'horizontal')]:
        ax.hist(
            d, bins=20,
            orientation=orientation, color=cmap(.4), edgecolor='white'
        )

    xy = np.column_stack([x, y])
    xymean = xy.mean(axis=0)
    xystd = xy.std(axis=0)
    xy -= xymean
    xy /= xystd
    pca = PCA().fit(xy)
    pc = (
        6 * xystd *
        pca.explained_variance_ratio_[:, np.newaxis] *
        pca.components_
    )

    for w, p in zip(pca.explained_variance_ratio_, pc):
        if np.all(p < 0):
            p *= -1
        ax_j.annotate(
            '', xymean + p, xymean, zorder=20,
            arrowprops=dict(
                arrowstyle='->', shrinkA=0, shrinkB=0,
                color=offblack, lw=.7
            )
        )
        ax_j.text(
            *(xymean + p + (.8, .002)*np.sign(p)), s='{:.0f}%'.format(100*w),
            color=offblack, ha='center', va='top' if p[1] < 0 else 'bottom',
            zorder=20
        )

    for ax in fig.axes:
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)

    for ax in ax_x, ax_y:
        ax.tick_params(
            bottom=False, left=False,
            labelbottom=False, labelleft=False
        )

    auto_ticks(ax_j, nbins=5, prune='upper')

    ax_j.set_xlim(xlim)
    ax_j.set_ylim(ylim)

    ax_j.set_xlabel(xlabel)
    ax_j.set_ylabel(ylabel)

    set_tight(pad=.1, h_pad=.3, w_pad=.3)


@plot
def pca_vectors_variance(system='PbPb2760'):
    """
    PCA vectors and explained variance.

    """
    fig, axes = plt.subplots(
        figsize=figsize(1.2, aspect=.4),
        ncols=2, gridspec_kw=dict(width_ratios=[5, 1])
    )

    emu = Trained_Emulators[system]
    pca = emu.pca

    ax = axes[0]

    for n, (pc, var) in enumerate(zip(
            pca.components_[:3], pca.explained_variance_ratio_
    ), start=1):
        ax.plot(pc, 'o', label='PC {} ({:.0f}%)'.format(n, 100*var))

    ax.axhline(
        0,
        color='.5', linewidth=plt.rcParams['ytick.major.width'],
        zorder=-100
    )

    x = -.5
    ticks = []
    ticklabels = []

    for obs, subobslist in emu.observables:
        for subobs in subobslist:
            i = model.data[system][obs][subobs]['Y'].shape[1]
            ticks.append(x + .5*i)
            ticklabels.append(obs_label(obs, subobs))
            x += i

    ax.set_xticks(ticks)
    ax.set_xticklabels(ticklabels)
    ax.tick_params(
        'x',
        bottom=False, labelbottom=False,
        labeltop=True, pad=1
    )
    for t in ax.get_xticklabels():
        t.set_verticalalignment('baseline')

    ax.set_ylim(-.1, .3)
    ax.set_ylabel('PCA coefficient', labelpad=1)
    auto_ticks(ax, 'y', nbins=4, minor=2)
    ax.legend(loc='upper left', handletextpad=0)

    ax = axes[1]

    npc = 10
    ax.plot(
        np.arange(1, 1 + npc),
        pca.explained_variance_ratio_.cumsum()[:npc],
        '-o',
    )

    ax.set_xlim(.5, npc + .5)
    ax.set_ylim(0, 1)

    majorticks = [1, 4, 7, 10]
    ax.set_xticks(majorticks)
    ax.set_xticks(sorted(set(range(1, npc)) - set(majorticks)), minor=True)
    auto_ticks(ax, 'y', nbins=5, minor=2)
    ax.xaxis.set_ticks_position('top')

    ax.set_xlabel('Number of PC')
    ax.set_ylabel('Cumulative explained variance fraction')
    ax.xaxis.set_ticks_position('top')
    ax.xaxis.set_label_position('top')

    for ax in axes:
        for s in ax.spines.values():
            s.set_visible(True)

    set_tight(w_pad=.5)

def boxplot(
        ax, percentiles, x=0, y=0, box_width=1,
        line_width=plt.rcParams['lines.linewidth'],
        color=(0, 0, 0), alpha=.6, zorder=10
):
    """
    Draw a minimal boxplot.

    `percentiles` must be a np.array of five numbers:

        whisker_low, quartile_1, median, quartile_3, whisker_high

    """
    pl, q1, q2, q3, ph = percentiles + y

    # IQR box
    ax.add_patch(patches.Rectangle(
        xy=(x - .5*box_width, q1),
        width=box_width, height=(q3 - q1),
        color=color, alpha=alpha, lw=0, zorder=zorder
    ))

    # median line
    ax.plot(
        [x - .5*box_width, x + .5*box_width], 2*[q2],
        lw=line_width, solid_capstyle='butt', color=color,
        zorder=zorder + 1
    )

    # whisker lines
    for y in [[q1, pl], [q3, ph]]:
        ax.plot(
            2*[x], y, lw=line_width, solid_capstyle='butt',
            color=color, alpha=alpha, zorder=zorder
        )

@plot
def diag_pca(system=system_strs[0]):
    """
    Diagnostic: histograms of principal components and scatterplots of pairs.

    """
    Y = [g.y_train_ for g in Trained_Emulators[system].gps]
    n = len(Y)
    ymax = np.ceil(max(np.fabs(y).max() for y in Y))
    lim = (-ymax, ymax)

    #fig, axes = plt.subplots(nrows=n, ncols=n, figsize=2*(n,))
    fig, axes = plt.subplots(nrows=n, ncols=n, figsize=(10,10))

    for y, ax in zip(Y, axes.diagonal()):
        ax.hist(y, bins=30)
        ax.set_xlim(lim)

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        ax = axes[ny][nx]
        ax.scatter(Y[nx], Y[ny])
        ax.set_xlim(lim)
        ax.set_ylim(lim)
        axes[nx][ny].set_axis_off()

    for i in range(n):
        label = 'PC {}'.format(i)
        axes[-1][i].set_xlabel(label)
        axes[i][0].set_ylabel(label)

    #plt.tight_layout()

@plot
def diag_emu(system=system_strs[0], pcs=None, label_all=True):
    """
    Diagnostic: plots of each principal component vs each input parameter,
    overlaid by emulator predictions at several points in design space.

    """
    gps = Trained_Emulators[system].gps
    pcs = (
        range(len(gps)) if pcs is None else
        [p if p >= 0 else (len(gps) + p) for p in pcs]
    )
    nrows = len(pcs)

    #get design points
    design_file = design_dir + \
           '/design_points_main_{:s}{:s}-{:d}.dat'.format(*systems[0])
    logging.info("Loading design points from " + design_file)
    design = pd.read_csv(design_file)
    design = design.drop("idx", axis=1)
    # get range
    range_file = design_dir + \
               '/design_ranges_main_{:s}{:s}-{:d}.dat'.format(*systems[0])
    design_range = pd.read_csv(range_file)
    design_max = design_range['max'].values
    design_min = design_range['min'].values


    params = design.keys()
    ncols = len(params)

    fig, axes = plt.subplots(
        nrows=nrows, ncols=ncols,
        figsize=figsize((.5 if label_all else .375)*ncols, .62*nrows/ncols),
        sharex=(False if label_all else 'col'),
        sharey=(False if label_all else 'row')
    )

    ymax = np.ceil(2*max(np.fabs(gps[pc].y_train_).max() for pc in pcs))/2
    ylim = (-ymax, ymax)

    tmax = int(ymax)
    yticksmajor = [-tmax, 0, tmax]
    yticksminor = list(range(-tmax + 1, 0)) + list(range(1, tmax))

    for pc, row in zip(pcs, axes):
        gp = gps[pc]
        y = gp.y_train_

        for i, (param, ax) in enumerate(zip(params, row)):
            x = gp.X_train_[:, i]
            ax.plot(
                x, y, 'o',
                markersize=.4*plt.rcParams['lines.markersize'],
                color='.7',
                zorder=-30
            )

            xlim = design_min[i], design_max[i]
            x = np.linspace(xlim[0], xlim[1], 100)
            X = np.empty((x.size, gp.X_train_.shape[1]))

            for r, c in [(.2, 'purple'), (.5, 'blue'), (.8, 'green')]:
                X[:] = r*design_min + (1 - r)*design_max
                X[:, i] = x
                mean, std = gp.predict(X, return_std=True)

                color = colors[c]
                ax.plot(
                    x, mean,
                    linewidth=.8*plt.rcParams['lines.linewidth'],
                    color=color,
                    zorder=-10
                )
                ax.fill_between(
                    x, mean - std, mean + std,
                    lw=0, color=color, alpha=.3, zorder=-20
                )

            ax.set_xlim(xlim)
            ax.set_ylim(ylim)

            auto_ticks(ax, 'x', nbins=3, minor=2)
            ax.set_yticks(yticksmajor)
            ax.set_yticks(yticksminor, minor=True)

            if label_all or ax.is_last_row():
                ax.set_xlabel(design.keys()[i])
            if label_all or ax.is_first_col():
                ax.set_ylabel('PC {}'.format(pc + 1))

    set_tight(fig, w_pad=.5, h_pad=.25)


@plot
def mcmc_trace(system=systems[0]):
    design_file = design_dir + \
           '/design_points_main_{:s}{:s}-{:d}.dat'.format(*system)
    design = pd.read_csv(design_file)
    design = design.drop("idx", axis=1)
    # get range
    range_file = design_dir + \
               '/design_ranges_main_{:s}{:s}-{:d}.dat'.format(*system)
    design_range = pd.read_csv(range_file)
    design_max = design_range['max'].values
    design_min = design_range['min'].values
    params = design.keys()

    chain = Chain().load()
    emcee_trace = chain.T
    fig, axes = plt.subplots(nrows=4, ncols=5, figsize=(15,15), sharex=True)
    for (i, param), ax in zip( enumerate(params), axes.flatten() ) :
        ax.plot(emcee_trace[0], emcee_trace[i], ',k', alpha=0.5);
        ax.set_xlabel(params[0])
        ax.set_ylabel(params[i])

    #plt.suptitle("MCMC trace")
    plt.tight_layout()


if __name__ == '__main__':
    import argparse
    from matplotlib.mathtext import MathTextWarning

    warnings.filterwarnings(
        'ignore',
        category=MathTextWarning,
        message='Substituting with a symbol from Computer Modern.'
    )
    warnings.filterwarnings(
        'ignore',
        category=UserWarning,
        message=r"'[\w\.]+' can not be subsetted into a Type 3 font."
    )

    choices = list(plot_functions)

    def arg_to_plot(arg):
        arg = Path(arg).stem
        if arg not in choices:
            raise argparse.ArgumentTypeError(arg)
        return arg

    parser = argparse.ArgumentParser(description='generate plots')
    parser.add_argument(
        '--paper', action='store_true',
        help='use paper style: cm serif font, true black text + axes'
    )
    parser.add_argument(
        'plots', nargs='*', type=arg_to_plot, metavar='PLOT',
        help='{} (default: all)'.format(', '.join(choices).join('{}'))
    )
    args = parser.parse_args()

    if args.paper:
        plt.rcParams.update({
            'font.family': 'serif',
            'font.serif': ['CMU Serif'],
            'mathtext.fontset': 'cm',
            'text.color': 'black',
            'axes.edgecolor': 'black',
            'axes.labelcolor': 'black',
            'xtick.color': 'black',
            'ytick.color': 'black',
        })

    if args.plots:
        for p in args.plots:
            plot_functions[p]()
    else:
        for f in plot_functions.values():
            f()
